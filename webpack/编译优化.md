[webpack优化第一篇](https://juejin.cn/post/6844903502586593288)
[webpack优化第二篇](https://juejin.cn/post/7083519723484708878)
[webpack优化第三篇](https://juejin.cn/post/6844904093463347208)

# 构建时间的优化
## thread-loader
多进程打包，可以大大提高构建的速度，使用方法是将thread-loader放在比较费时间的loader之前，比如babel-loader
```
// webpack.base.js

{
        test: /\.js$/,
        use: [
          'thread-loader',
          'babel-loader'
        ],
      }
}
```
## cache-loader
缓存资源，提高二次构建的速度，使用方法是将cache-loader放在比较费时间的loader之前，比如babel-loader
```
// webpack.base.js

{
        test: /\.js$/,
        use: [
          'cache-loader',
          'thread-loader',
          'babel-loader'
        ],
},
```
## happypack
由于有大量文件需要解析和处理，构建是文件读写和计算密集型的操作，特别是当文件数量变多后，Webpack 构建慢的问题会显得严重。文件读写和计算操作是无法避免的，那能不能让 Webpack 同一时刻处理多个任务，发挥多核 CPU 电脑的威力，以提升构建速度呢？
HappyPack 就能让 Webpack 做到这点，它把任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程。
```
const Happypack = require('happypack');
module.exports = {
    //...
    module: {
        rules: [
            {
                test: /\.js[x]?$/,
                use: 'Happypack/loader?id=js',
                include: [path.resolve(__dirname, 'src')]
            },
            {
                test: /\.css$/,
                use: 'Happypack/loader?id=css',
                include: [
                    path.resolve(__dirname, 'src'),
                    path.resolve(__dirname, 'node_modules', 'bootstrap', 'dist')
                ]
            }
        ]
    },
    plugins: [
        new Happypack({
            id: 'js', //和rule中的id=js对应
            //将之前 rule 中的 loader 在此配置
            use: ['babel-loader'] //必须是数组
        }),
        new Happypack({
            id: 'css',//和rule中的id=css对应
            use: ['style-loader', 'css-loader','postcss-loader'],
        })
    ]
}
```
## 开启热更新
比如你修改了项目中某一个文件，会导致整个项目刷新，这非常耗时间。如果只刷新修改的这个模块，其他保持原状，那将大大提高修改代码的重新构建时间
```
// webpack.dev.js

//引入webpack
const webpack = require('webpack');
//使用webpack提供的热更新插件
   plugins: [
   new webpack.HotModuleReplacementPlugin()
    ],
    //最后需要在我们的devserver中配置
     devServer: {
+     hot: true
    },
```
## 开启 JS 多进程压缩
虽然很多 webpack 优化的文章上会提及多进程压缩的优化，不管是 webpack-parallel-uglify-plugin 或者是 uglifyjs-webpack-plugin 配置 parallel。不过这里我要说一句，没必要单独安装这些插件，它们并不会让你的 Webpack 构建速度提升。
当前 Webpack 默认使用的是 TerserWebpackPlugin，默认就开启了多进程和缓存，构建时，你的项目中可以看到 terser 的缓存文件 node_modules/.cache/terser-webpack-plugin。

## HardSourceWebpackPlugin
HardSourceWebpackPlugin 为模块提供中间缓存，缓存默认的存放路径是: node_modules/.cache/hard-source。
配置 hard-source-webpack-plugin，首次构建时间没有太大变化，但是第二次开始，构建时间大约可以节约 80%。
```
//webpack.config.js
var HardSourceWebpackPlugin = require('hard-source-webpack-plugin');
module.exports = {
    //...
    plugins: [
        new HardSourceWebpackPlugin()
    ]
}
```
## noParse
如果一些第三方模块没有AMD/CommonJS规范版本，可以使用 noParse 来标识这个模块，这样 Webpack 会引入这些模块，但是不进行转化和解析，从而提升 Webpack 的构建性能 ，例如：jquery 、lodash。
noParse 属性的值是一个正则表达式或者是一个 function
```
//webpack.config.js
module.exports = {
    //...
    module: {
        noParse: /jquery|lodash/
    }
}
```
我当前的 webpack-optimize 项目中，没有使用 jquery 或者是 lodash。
因此新建一个项目测试，只引入 jquery 和 loadsh，然后配置 noParse 和不配置 noParse，分别构建比对时间。
配置noParse 前，构建需要 2392ms。配置了 noParse 之后，构建需要 1613ms。 如果你使用到了不需要解析的第三方依赖，那么配置 noParse 很显然是一定会起到优化作用的。

## IgnorePlugin
webpack 的内置插件，作用是忽略第三方包指定目录。
例如: moment (2.24.0版本) 会将所有本地化内容和核心功能一起打包，我们就可以使用 IgnorePlugin 在打包时忽略本地化内容。
```
//webpack.config.js
module.exports = {
    //...
    plugins: [
        //忽略 moment 下的 ./locale 目录
        new webpack.IgnorePlugin(/^\.\/locale$/, /moment$/)
    ]
}
```
在使用的时候，如果我们需要指定语言，那么需要我们手动的去引入语言包，例如，引入中文语言包:
```
import moment from 'moment';
import 'moment/locale/zh-cn';// 手动引入
```
index.js 中只引入 moment，打包出来的 bundle.js 大小为 263KB，如果配置了 IgnorePlugin，单独引入 moment/locale/zh-cn，构建出来的包大小为 55KB。

## externals
我们可以将一些JS文件存储在 CDN 上(减少 Webpack打包出来的 js 体积)，在 index.html 中通过 <script> 标签引入，如:
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <div id="root">root</div>
    <script src="http://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>
</body>
</html>
```
我们希望在使用时，仍然可以通过 import 的方式去引用(如 import $ from 'jquery')，并且希望 webpack 不会对其进行打包，此时就可以配置 externals。
```
//webpack.config.js
module.exports = {
    //...
    externals: {
        //jquery通过script引入之后，全局中即有了 jQuery 变量
        'jquery': 'jQuery'
    }
}
```
## DllPlugin
有些时候，如果所有的JS文件都打成一个JS文件，会导致最终生成的JS文件很大，这个时候，我们就要考虑拆分 bundles。
DllPlugin 和 DLLReferencePlugin 可以实现拆分 bundles，并且可以大大提升构建速度，DllPlugin 和 DLLReferencePlugin 都是 webpack 的内置模块。
我们使用 DllPlugin 将不会频繁更新的库进行编译，当这些依赖的版本没有变化时，就不需要重新编译。我们新建一个 webpack 的配置文件，来专门用于编译动态链接库，例如名为: webpack.config.dll.js，这里我们将 react 和 react-dom 单独打包成一个动态链接库。

```
//webpack.config.dll.js
const webpack = require('webpack');
const path = require('path');

module.exports = {
    entry: {
        react: ['react', 'react-dom']
    },
    mode: 'production',
    output: {
        filename: '[name].dll.[hash:6].js',
        path: path.resolve(__dirname, 'dist', 'dll'),
        library: '[name]_dll' //暴露给外部使用
        //libraryTarget 指定如何暴露内容，缺省时就是 var
    },
    plugins: [
        new webpack.DllPlugin({
            //name和library一致
            name: '[name]_dll', 
            path: path.resolve(__dirname, 'dist', 'dll', 'manifest.json') //manifest.json的生成路径
        })
    ]
}
```
在 package.json 的 scripts 中增加:
```
{
    "scripts": {
        "dev": "NODE_ENV=development webpack-dev-server",
        "build": "NODE_ENV=production webpack",
        "build:dll": "webpack --config webpack.config.dll.js"
    },
}
```
执行 npm run build:all，可以看到 dist 目录如下，之所以将动态链接库单独放在 dll 目录下，主要是为了使用 CleanWebpackPlugin 更为方便的过滤掉动态链接库。
```
dist
└── dll
    ├── manifest.json
    └── react.dll.9dcd9d.js
```
manifest.json 用于让 DLLReferencePlugin 映射到相关依赖上。
修改 webpack 的主配置文件: webpack.config.js 的配置：
```
//webpack.config.js
const webpack = require('webpack');
const path = require('path');
module.exports = {
    //...
    devServer: {
        contentBase: path.resolve(__dirname, 'dist')
    },
    plugins: [
        new webpack.DllReferencePlugin({
            manifest: path.resolve(__dirname, 'dist', 'dll', 'manifest.json')
        }),
        new CleanWebpackPlugin({
            cleanOnceBeforeBuildPatterns: ['**/*', '!dll', '!dll/**'] //不删除dll目录
        }),
        //...
    ]
}
```
使用 npm run build 构建，可以看到 bundle.js 的体积大大减少。
修改 public/index.html 文件，在其中引入 react.dll.js
```
<script src="/dll/react.dll.9dcd9d.js"></script>
```
## babel配置的优化
根据合适的项目选择合适的babel配置
## exclude & include
exclude：不需要处理的文件
include：需要处理的文件
```
// webpack.base.js

      {
        test: /\.js$/,
        //使用include来指定编译文件夹
        include: path.resolve(__dirname, '../src'),
        //使用exclude排除指定文件夹
        exclude: /node_modules/,
        use: [
          'babel-loader'
        ]
      },
```
## 构建区分环境

区分环境去构建是非常重要的，我们要明确知道，开发环境时我们需要哪些配置，不需要哪些配置；而最终打包生产环境时又需要哪些配置，不需要哪些配置：

开发环境：去除代码压缩、gzip、体积分析等优化的配置，大大提高构建速度
生产环境：需要代码压缩、gzip、体积分析等优化的配置，大大降低最终项目打包体积

## 提升webpack版本
版本越新，打包的效果肯定更好

# 打包体积优化

主要是打包后项目整体体积的优化，有利于项目上线后的页面加载速度提升

现在越来越多的项目都使用 ES2015+ 开发，并且搭配 webpack + babel 作为工程化基础，并通过 NPM 去加载第三方依赖库。同时为了达到代码复用的目的，我们会把一些自己开发的组件库或者是 JSSDK 抽成独立的仓库维护，并通过 NPM 去加载。

## 这样的开发方式隐藏了两个问题：

### 代码冗余
一般来说，这些 NPM 包也是基于 ES2015+ 开发的，每个包都需要经过 babel 编译发布后才能被主应用使用，而这个编译过程往往会附加很多“编译代码”；每个包都会有一些相同的编译代码，这就造成大量代码的冗余，并且这部分冗余代码是不能通过 Tree Shaking 等技术去除掉的。

### 非必要的依赖
考虑到组件库的场景，通常我们为了方便一股脑引入了所有组件；但实际情况下对于一个应用而言可能只是用到了部分组件，此时如果全部引入，也会造成代码冗余。

代码的冗余会造成静态资源包加载时间变长、执行时间也会变长，进而很直接的影响性能和体验。既然我们已经认识到有此类问题，那么接下来看看如何解决这两个问题。

## 拆包打包
为了降低包大小，经常会把依赖的前端模块独立打包，比如把 vue、vue-router 打到一个单独的包 vendor 中。另外，常会将存在多个路由的复杂页面的每个页面都单独打一个包，只有访问某个页面的时候，再去下载该页面的js包，以此来加快首页的渲染。
[原文链接1](https://juejin.cn/post/6939708814555873311)
[原文链接2](https://juejin.cn/post/6844904103848443912)
[原文链接3](https://juejin.cn/post/6844904183917871117)

**打包优化中心思想**

* 1、优化用户体验

减少首屏加载时间
提升各项交互的流畅度，如表单验证和页面切换

* 2、优化开发体验

减少构建耗时
自动化完成一些重复工作，解放生产力，脚手架是代表性产物

* 3、webpack 提供了模块化项目中最主要的优化手段：

提取公共代码
按需加载（懒加载）
### webpack代码分割的三种方式

* 入口起点：使用 entry 配置手动地分离代码。
* 动态导入：通过模块的内联函数调用来分离代码。
* 防止重复：使用 splitChunks 去重和分离 chunk。

#### 第一种方式
只需要在 entry 里配置多个入口即可：

entry: { app: "./index.js", app1: "./index1.js" }

#### 第二种方式
在代码中自动将使用 es module 的 import() 加载的模块分离成独立的包 commonJS使用require.ensure() 是 webpack 特有的，已被 import() 取代。给定 dependencies 参数，将其对应的文件拆分到一个单独的 bundle 中，此 bundle 会被异步加载。当使用 CommonJS 模块语法时，这是动态加载依赖项的唯一方法。这意味着，可以在模块执行时才允许代码，只有在满足特定条件时才会加载 dependencies。这个特性依赖内置的 Promise。如果你在低版本浏览器中使用 require.ensure，记得使用像 es6-promise 或 promise-polyfill 这样的 polyfill 库，预先填充（shim）Promise 环境。var a = require('normal-dep');


```
require.ensure(
  dependencies: String[],
  callback: function(require),
  errorCallback: function(error),
  chunkName: String
)

if (module.hot) {
  require.ensure(['b'], function (require) {
    var c = require('c');

    // Do something special...
  });
}
```

* dependencies：字符串数组，声明 callback 回调函数中所需要的所有模块。
* callback：当依赖项加载完成后，webpack 将会执行此函数，require 函数的实现，作为参数传入此函数中。当程序运行需要依赖时，可以使用 require() 来加载依赖。函数体可以使用此参数，来进一步执行 require() 模块。
* errorCallback：当 webpack 加载依赖失败时会执行此函数。
* chunkName：由 require.ensure 创建的 chunk 的名称。通过将相同 chunkName 传递给不同的 require.ensure 调用，我们可以将其代码合并到一个单独的 chunk 中，从而只产生一个浏览器必须加载的 bundle。虽然将 require 的实现作为参数（可以使用任意名称）传递给 callback 函数，例如，require.ensure([], function(request) { request('someModule'); }) 则不能被 webpack 静态解析器处理，因此还是使用 require 作为参数名，例如，require.ensure([], function(require) { require('someModule') })。

#### 第三种方式
1、使用 splitChunks 插件，配置分离规则，然后 webpack 自动将满足规则的 chunk 分离，实现去重和分离chunk。
2、除了splitChunks还有 默认情况下，每个入口 chunk 保存了全部其用的模块(modules)。使用 dependOn 选项你可以与另一个入口 chunk 共享模块:
```
module.exports = {
  //...
  entry: {
    app: { import: './app.js', dependOn: 'react-vendors' },
    'react-vendors': ['react', 'react-dom', 'prop-types'],
  },
};
app 这个 chunk 就不会包含 react-vendors 拥有的模块了.
dependOn 选项的也可以为字符串数组：
module.exports = {
  //...
  entry: {
    moment: { import: 'moment-mini', runtime: 'runtime' },
    reactvendors: { import: ['react', 'react-dom'], runtime: 'runtime' },
    testapp: {
      import: './wwwroot/component/TestApp.tsx',
      dependOn: ['reactvendors', 'moment'],
    },
  },
};

此外，你还可以使用数组为每个入口指定多个文件：

module.exports = {
  //...
  entry: {
    app: { import: ['./app.js', './app2.js'], dependOn: 'react-vendors' },
    'react-vendors': ['react', 'react-dom', 'prop-types'],
  },
};
```
##### splitchunks
webpack5的splitchunks的默认值
```
module.exports = {
  //...
  optimization: {
    splitChunks: {
      chunks: 'async',// 指明要分割的插件类型, async:异步插件(动态导入),inital:同步插件,all：全部类型
      minSize: 20000,// 文件最小大小,单位bite;即超过minSize有可能被分割；
      minRemainingSize: 0,// webpack5新属性，防止0尺寸的chunk
      maxSize: 0,
      minChunks: 1,
      maxAsyncRequests: 30,// webpack4,5区别较大
      maxInitialRequests: 30,// webpack4,5区别较大
      enforceSizeThreshold: 50000,
      cacheGroups: {
        defaultVendors: {
          test: /[\\/]node_modules[\\/]/,
          priority: -10,
          reuseExistingChunk: true
        },
        default: {
          minChunks: 2,
          priority: -20,
          reuseExistingChunk: true
        }
      }
    }
  }
};
```
**五个关键属性**
```
1、minSize(默认 30000)：使得比这个值大的模块才会被打包成chunk。
2、minChunks（默认 1）：用于界定至少重复多少次的模块才会被打包成chunk。
3、maxInitialRequests（默认 3）：一个代码块最终就会对应一个请求数，所以该属性决定入口最多分成的代码块数量，太小的值会使你无论怎么分割，都无法让满足拆分chunk的文件别单独打包引入。
4、maxAsyncRequests（默认 5）：同上，决定每次按需加载时，代码块的最大数量。
5、test：通过正则表达式精准匹配要提取的模块，可以根据项目结构制定各种规则，是手动优化的关键。
```
**宝藏属性 Name**
- 值为 true 的时候，webpack 会基于代码块和缓存组的 key 自动选择一个名称，这样一个缓存组会打包出多个 chunk。
- 值为 false 时，适合生产模式使用，webpack 会避免对 chunk 进行不必要的命名，以减小打包体积，除了入口 chunk 外，其他 chunk 的名称都由 id 决定，所以最终看到的打包结果是一排数字命名的 js，这也是为啥我们看线上网页请求的资源，总会掺杂一些 0.js，1.js 之类的文件(当然，使资源名为数字 id 的方式不止这一种，懒加载也能轻松办到，且看下文)。
- 值为 string 时，缓存组最终会打包成一个 chunk，名称就是该 string。此外，当两个缓存组 name 一样，最终会打包在一个 chunk 中。你甚至可以把它设为一个入口的名称，从而将这个入口会移除。

###### 如何使用prefetch和preload来加载异步chunk js文件
[原文链接](https://juejin.cn/post/6921606847359582215)
假设我们某个异步chunks是被分割，那么我们怎么怎么使用prefetch和preload来优化页面的加载时间呢？ 那就要用到：预获取/预加载模块。webpack v4.6.0+ 增加了对预获取和预加载的支持。在声明 import 时，使用下面这些内置指令，可以让 webpack 输出 "resource hint(资源提示)"，来告知浏览器：prefetch(预获取)：将来某些导航下可能需要的资源preload(预加载)：当前导航下可能需要资源
```
//...
import(/* webpackPrefetch: true */ './path/to/LoginModal.js');
//...
import(/* webpackPreload: true */ 'ChartingLibrary');

```
**为什么我们vue框架中没有使用resource hint，webpack依然生成了预加载和预获取的link标签呢？**

答：因为Vue CLI 也会自动注入 resource hint (preload/prefetch、manifest 和图标链接 (当用到 PWA 插件时) 以及构建过程中处理的 JavaScript 和 CSS 文件的资源链接。@vue/cli-service中引入了@vue/preload-webpack-plugin，默认情况下，一个 Vue CLI 应用会为所有初始化渲染需要的文件自动生成 preload 提示。这些提示会被@vue/preload-webpack-plugin 注入，并且可以通过 chainWebpack 的 config.plugin('preload') 进行修改和删除。

有人可能跟我一样，遇到了prefetch加载两次资源且用时一样的情况，那么原因是为什么呢？ 这种情况有一种原因，那就是你再用dev-tool调试的时候打开了disable:cache功能，这样子prefetch过的资源会无视缓存重新请求，当你把disable:cache关闭之后，第二次的time用时就会变得非常小，几毫秒

**很多人说自己的prefetch和preload不生效**

答：那有可能是浏览器的问题，因为这两个功能是html5的新功能，浏览器厂商支持情况不一样
###### initial加载
```
var path = require("path");

module.exports = {
  mode: "development",
//   mode: "production",
  entry: {
    pageA: "./pageA",
    pageB: "./pageB",
    pageC: "./pageC",
  },
  optimization: {
    chunkIds: "named", // 指定打包过程中的chunkId，设为named会生成可读性好的chunkId，便于debug
    splitChunks: {
	  name:false, // name默认为true
      minSize: 0, // 默认30000（30kb），但是demo中的文件都很小，minSize设为0，让每个文件都满足大小条件
      cacheGroups: {
        commons: {
          chunks: "initial",
		  // 这表明将选择哪些 chunk 进行优化。当提供一个字符串，有效值为 all，async(异步) 和 initial(同步)。设置为 all 可能特别强大，因为这意味着 chunk 可以在异步和非异步 chunk 之间共享。
		//   name: "commons",
          minChunks: 2, // 打包到commons的cacheGroups的分包需要满足至少被多少个包引入的规则 因为utility1只被pageA引入，所以不会打包到commons chunk 中
          maxInitialRequests: 5, // 默认为3 每个入口chunk最多由几个chunk分包组成，由于一开始设置的是3 所以即使utility3被引入了2两次 也没有被单独打包到commons chunk中 所以改成5看看utility3的打包情况
		  // 可以看到将maxInitialRequests改成5之后 pageB内有了utility3的分包
        },
        vendor: {
          test: /node_modules/,
          chunks: "initial",
          name: "vendor", 
		// 从打包结果上可以看出node_modules中的vendor1 和 vendor2 被打包到了同一个chunk vendor中，但是上面的common分包下的utility2和utility3却被打包成了commons-utility2_js.js 和 commons-utility3_js.js
		// 可以看出是因为我们在vendor包中加了name属性 如果我们将vendor中的那么属性去掉
		// 那么vendor1 和 vendor2 将被打包成 vendor-node_modules_vendor1_js.js 和 vendor-node_modules_vendor2_js.js
		// 如果给commons添加了name commons 那么commons中将会打包utility2和utility3被pageA pageB pageC引用
        },
      },
    },
  },
  output: {
    path: path.join(__dirname, "dist"),
    filename: "[name].js",
  },
};
```
###### async 
```
var path = require("path");
// 如果项目仅仅只在pageA中引入async1 和 async2 那么 utility1 不会被单独打包出来
// 因为：utility1.js 同时被 pageA.js，async1.js，async2.js 三个模块引用，照理应该命中 commons 缓存组的规则，从而被单独提取成一个 chunk，
// 然而结果是它依然打包在 pageA.js 中。这是因为 async1.js，async2.js 都是 pageA.js 的懒加载模块，
// 而 pageA.js 同步引用了 utility1.js，所以在加载 async1.js，async2.js 时 utility1.js 已经有了，直接拿来用即可，所以就没必要提出一个新的 chunk，白白增加一个请求。
// 如果想要utility1被单独提取出来可以在pageB页面中异步加载async1和async2
module.exports = {
	mode: "development",
	// mode: "production",
	entry: {
		pageA: "./pageA",
		pageB: "./pageB",
		pageC: "./pageC"
	},
	optimization: {
		chunkIds: "named",
		splitChunks: {
			minSize: 0,
			name:false,
			cacheGroups: {
				commons: {
					chunks: "all",//加入按需加载后，设为all将所有模块包括在优化范围内
					// name: "commons",
					minChunks: 2,
					maxInitialRequests: 5, // 默认为3，无法满足我们的分包数量
				},
				vendor: {
					test: /node_modules/,
					chunks: "initial",
					name: "vendor",
					// priority: 10,
					// enforce: true
				}
			}
		}
	},
	output: {
		path: path.join(__dirname, "dist"),
		filename: "[name].js",
	}
};

```
## 后编译(解决多个相同依赖生成多份的问题)
指的是应用依赖的 NPM 包并不需要在发布前编译，而是随着应用编译打包的时候一块编译。后编译的核心在于把编译依赖包的时机延后，并且**统一编译**；先来看看它的 webpack 配置。对具体项目应用而言，做到后编译，其实不需要做太多，只需要在 webpack 的配置文件中，包含需要我们去后编译的依赖包即可（webpack 2+）：公共的依赖可以实现共用，只此一份，重要的是只编译一次，建议通过 peerDependencies 管理依赖。babel 转换 API（例如 babel-plugin-transform-runtime 或者 babel-polyfill）部分的代码只有一份。不用每个依赖包都需要配置编译打包环节，甚至可以直接源码级别发布。
```
// webpack.config.js
module.exports = {
  // ...
  module: {
    rules: [
      // ...
      {
        test: /\.js$/,
        loader: 'babel-loader',
        // 注意这里的 include
        // 除了 src 还包含了额外的 node_modules 下的两个包
        include: [
            resolve('src'),
            resolve('node_modules/A'),
            resolve('node_modules/B')
          ]
      },
      // ...
    ]
  },
  // ...
}
```
如果某应用中依赖了需要后编译的包 A 和 B，而 A 又依赖了需要后编译的包 C 和 D，B 依赖了不需要后编译的包 E；重点来看依赖包 A 的情况：A 本身需要后编译，然后 A 的依赖包 C 和 D 也需要后编译，这种场景我们可以称之为嵌套后编译，此时如果依旧通过上边的 webpack 配置方式的话，还必须要显示的去 include 包 C 和 D，但对于应用而言，它只知道自身需要后编译的包 A 和 B，并不知道 A 也会有需要后编译的包 C 和 D，所以应用不应该显示的去 include 包 C 和 D，而是应该由 A 显示的去声明自己需要哪些后编译模块。 为了解决上述嵌套后编译问题，我们开发了一个 webpack 插件 webpack-post-compile-plugin，用于自动收集后编译的依赖包以及其嵌套依赖；来看下这个插件的核心代码,原理就是在 webpack compiler 的 before-run 和 watch-run 事件钩子中去收集依赖然后附加到 webpack module.rule 的 include 上；收集的规则就是查找应用或者依赖包的 package.json 中声明的 compileDependencies 作为后编译依赖。
```
var util = require('./util')

function PostCompilePlugin (options) {
  // ...
}

PostCompilePlugin.prototype.apply = function (compiler) {
  var that = this
  compiler.plugin(['before-run', 'watch-run'], function (compiler, callback) {
    // ...
    var dependencies = that._collectCompileDependencies(compiler)
    if (dependencies.length) {
      var rules = compiler.options.module.rules
      rules && rules.forEach(function (rule) {
        if (rule.include) {
          if (!Array.isArray(rule.include)) {
            rule.include = [rule.include]
          }
          rule.include = rule.include.concat(dependencies)
        }
      })
    }
    callback()
  })
}
```
```
var PostCompilePlugin = require('webpack-post-compile-plugin')
// webpack.config.js
module.exports = {
  // ...
  module: {
    rules: [
      // ...
      {
        test: /\.js$/,
        loader: 'babel-loader',
        include: [
            resolve('src')
          ]
      },
      // ...
    ]
  },
  // ...
  plugins: [
    new PostCompilePlugin()
  ]
}
```
当前项目的 package.json 中添加 compileDependencies 字段来指定后编译依赖包
```
// app package.json
{
  // ...
  "compileDependencies": ["A", "B"]
  // ...
}
```
A 还有后编译依赖，所以需要在包 A 的 package.json 中指定 compileDependencies：
// A package.json
{
  // ...
  "compileDependencies": ["C", "D"]
  // ...
}
### 优点
公共的依赖可以实现共用，只此一份，重要的是只编译一次，建议通过 peerDependencies 管理依赖。
babel 转换 API（例如 babel-plugin-transform-runtime 或者 babel-polyfill）部分的代码只有一份。
不用每个依赖包都需要配置编译打包环节，甚至可以直接源码级别发布。
PS: 关于 babel-plugin-transform-runtime 和 babel-polyfill 的选择问题，对于应用而言，我们建议的是采用 babel-polyfill。因为一些第三方包的依赖会判断全局是否支持某些特性，而不去做 polyfill 处理。例如：vuex 会检查是否支持 Promise，如果不支持则会报错；或者说在代码中有类似 "foobar".includes("foo") 的代码的话 babel-plugin-transform-runtime 也是不能正确处理的
### 缺点
主应用的 babel 配置需要能兼容依赖包的 babel 配置。
依赖包不能使用 alias、不能方便的使用 DefinePlugin（可以经过一次简单编译，但是不做 babel 处理）。
应用编译时间会变长。
## 按需引入
后编译主要解决的问题是代码冗余，而按需引入主要是用来解决非必要的依赖的问题。按需引入针对的场景主要是组件库、工具类依赖包。因为不管是组件库还是依赖包，往往都是“大而全”的，而在开发应用的时候，我们可能只是使用了其一部分能力，如果全部引入的话，会有很多资源浪费。为了解决这个问题，我们需要按需引入。目前主流组件库或者工具包也都是提供按需引入能力的，但是基本都是提供对编译后模块引入。而我们推荐的是对源码的按需引入，配合后编译的打包方案。
## CSS代码压缩
CSS代码压缩使用css-minimizer-webpack-plugin，效果包括压缩、去重

代码的压缩比较耗时间，所以只用在打包项目时，所以只需要在webpack.prod.js中配置
```
// webpack.prod.js

const CssMinimizerPlugin = require('css-minimizer-webpack-plugin')

optimization: {
    minimizer: [
        new CssMinimizerPlugin(), // 去重压缩css
    ],
}
```
## JS代码压缩
JS代码压缩使用terser-webpack-plugin，实现打包后JS代码的压缩
```
// webpack.prod.js

const TerserPlugin = require('terser-webpack-plugin')

  optimization: {
    minimizer: [
      new CssMinimizerPlugin(), // 去重压缩css
      new TerserPlugin({ // 压缩JS代码
        terserOptions: {
          compress: {
            drop_console: true, // 去除console
          },
        },
      }), // 压缩JavaScript
    ],
  }
```
## tree-shaking
tree-shaking简单说作用就是：只打包用到的代码，没用到的代码不打包，而webpack5默认开启tree-shaking，当打包的mode为production时，自动开启tree-shaking进行优化
```
module.exports = {
  mode: 'production'
}
```
## source-map类型
source-map的作用是：方便你报错的时候能定位到错误代码的位置。它的体积不容小觑，所以对于不同环境设置不同的类型是很有必要的。
### 开发环境
开发环境的时候我们需要能精准定位错误代码的位置
```
// webpack.dev.js

module.exports = {
  mode: 'development',
  devtool: 'eval-cheap-module-source-map'
}
```

### 生产环境
生产环境，我们想开启source-map，但是又不想体积太大，那么可以换一种类型
```
// webpack.prod.js

module.exports = {
  mode: 'production',
  devtool: 'nosources-source-map'
}
```
## 打包体积分析

使用webpack-bundle-analyzer可以审查打包后的体积分布，进而进行相应的体积优化

只需要打包时看体积，所以只需在webpack.prod.js中配置

```
// webpack.prod.js

const {
  BundleAnalyzerPlugin
} = require('webpack-bundle-analyzer')

  plugins: [
    new BundleAnalyzerPlugin(),
]
```
# 用户体验优化

## 模块懒加载
如果不进行模块懒加载的话，最后整个项目代码都会被打包到一个js文件里，单个js文件体积非常大，那么当用户网页请求的时候，首屏加载时间会比较长，使用模块懒加载之后，大js文件会分成多个小js文件，网页加载时会按需加载，大大提升首屏加载速度

```
// src/router/index.js

const routes = [
  {
    path: '/login',
    name: 'login',
    component: login
  },
  {
    path: '/home',
    name: 'home',
    // 懒加载
    component: () => import('../views/home/home.vue'),
  },
]
```
## Gzip

开启Gzip后，大大提高用户的页面加载速度，因为gzip的体积比原文件小很多，当然需要后端的配合，使用compression-webpack-plugin

```
// webpack.prod.js

const CompressionPlugin = require('compression-webpack-plugin')

  plugins: [
    // 之前的代码...
    
    // gzip
    new CompressionPlugin({
      algorithm: 'gzip',
      threshold: 10240,
      minRatio: 0.8
    })
  ]

```
## 小图片转base64
对于一些小图片，可以转base64，这样可以减少用户的http网络请求次数，提高用户的体验。webpack5中url-loader已被废弃，改用asset-module

```
// webpack.base.js

{
   test: /\.(png|jpe?g|gif|svg|webp)$/,
   type: 'asset',
   parser: {
     // 转base64的条件
     dataUrlCondition: {
        maxSize: 25 * 1024, // 25kb
     }
   },
   generator: {
     // 打包到 image 文件下
    filename: 'images/[contenthash][ext][query]',
   },
},
```
## 合理配置hash
我们要保证，改过的文件需要更新hash值，而没改过的文件依然保持原本的hash值，这样才能保证在上线后，浏览器访问时没有改变的文件会命中缓存，从而达到性能优化的目的
```
// webpack.base.js

  output: {
    path: path.resolve(__dirname, '../dist'),
    // 给js文件加上 contenthash
    filename: 'js/chunk-[contenthash].js',
    clean: true,
  },
```