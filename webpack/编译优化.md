[webpack优化第一篇](https://juejin.cn/post/6844903502586593288)
[webpack优化第二篇](https://juejin.cn/post/7083519723484708878)


# 构建时间的优化

## thread-loader
多进程打包，可以大大提高构建的速度，使用方法是将thread-loader放在比较费时间的loader之前，比如babel-loader
```
// webpack.base.js

{
        test: /\.js$/,
        use: [
          'thread-loader',
          'babel-loader'
        ],
      }
}
```
## cache-loader
缓存资源，提高二次构建的速度，使用方法是将cache-loader放在比较费时间的loader之前，比如babel-loader
```
// webpack.base.js

{
        test: /\.js$/,
        use: [
          'cache-loader',
          'thread-loader',
          'babel-loader'
        ],
},
```

## 开启热更新
比如你修改了项目中某一个文件，会导致整个项目刷新，这非常耗时间。如果只刷新修改的这个模块，其他保持原状，那将大大提高修改代码的重新构建时间
```
// webpack.dev.js

//引入webpack
const webpack = require('webpack');
//使用webpack提供的热更新插件
   plugins: [
   new webpack.HotModuleReplacementPlugin()
    ],
    //最后需要在我们的devserver中配置
     devServer: {
+     hot: true
    },
```
## exclude & include
exclude：不需要处理的文件
include：需要处理的文件
```
// webpack.base.js

      {
        test: /\.js$/,
        //使用include来指定编译文件夹
        include: path.resolve(__dirname, '../src'),
        //使用exclude排除指定文件夹
        exclude: /node_modules/,
        use: [
          'babel-loader'
        ]
      },
```
## 构建区分环境

区分环境去构建是非常重要的，我们要明确知道，开发环境时我们需要哪些配置，不需要哪些配置；而最终打包生产环境时又需要哪些配置，不需要哪些配置：

开发环境：去除代码压缩、gzip、体积分析等优化的配置，大大提高构建速度
生产环境：需要代码压缩、gzip、体积分析等优化的配置，大大降低最终项目打包体积

## 提升webpack版本
版本越新，打包的效果肯定更好

# 打包体积优化

主要是打包后项目整体体积的优化，有利于项目上线后的页面加载速度提升

现在越来越多的项目都使用 ES2015+ 开发，并且搭配 webpack + babel 作为工程化基础，并通过 NPM 去加载第三方依赖库。同时为了达到代码复用的目的，我们会把一些自己开发的组件库或者是 JSSDK 抽成独立的仓库维护，并通过 NPM 去加载。

## 这样的开发方式隐藏了两个问题：

### 代码冗余
一般来说，这些 NPM 包也是基于 ES2015+ 开发的，每个包都需要经过 babel 编译发布后才能被主应用使用，而这个编译过程往往会附加很多“编译代码”；每个包都会有一些相同的编译代码，这就造成大量代码的冗余，并且这部分冗余代码是不能通过 Tree Shaking 等技术去除掉的。

### 非必要的依赖
考虑到组件库的场景，通常我们为了方便一股脑引入了所有组件；但实际情况下对于一个应用而言可能只是用到了部分组件，此时如果全部引入，也会造成代码冗余。

代码的冗余会造成静态资源包加载时间变长、执行时间也会变长，进而很直接的影响性能和体验。既然我们已经认识到有此类问题，那么接下来看看如何解决这两个问题。
## 后编译
指的是应用依赖的 NPM 包并不需要在发布前编译，而是随着应用编译打包的时候一块编译。后编译的核心在于把编译依赖包的时机延后，并且统一编译；先来看看它的 webpack 配置。对具体项目应用而言，做到后编译，其实不需要做太多，只需要在 webpack 的配置文件中，包含需要我们去后编译的依赖包即可（webpack 2+）：
```
// webpack.config.js
module.exports = {
  // ...
  module: {
    rules: [
      // ...
      {
        test: /\.js$/,
        loader: 'babel-loader',
        // 注意这里的 include
        // 除了 src 还包含了额外的 node_modules 下的两个包
        include: [
            resolve('src'),
            resolve('node_modules/A'),
            resolve('node_modules/B')
          ]
      },
      // ...
    ]
  },
  // ...
}
```
如果某应用中依赖了需要后编译的包 A 和 B，而 A 又依赖了需要后编译的包 C 和 D，B 依赖了不需要后编译的包 E；重点来看依赖包 A 的情况：A 本身需要后编译，然后 A 的依赖包 C 和 D 也需要后编译，这种场景我们可以称之为嵌套后编译，此时如果依旧通过上边的 webpack 配置方式的话，还必须要显示的去 include 包 C 和 D，但对于应用而言，它只知道自身需要后编译的包 A 和 B，并不知道 A 也会有需要后编译的包 C 和 D，所以应用不应该显示的去 include 包 C 和 D，而是应该由 A 显示的去声明自己需要哪些后编译模块。 为了解决上述嵌套后编译问题，我们开发了一个 webpack 插件 webpack-post-compile-plugin，用于自动收集后编译的依赖包以及其嵌套依赖；来看下这个插件的核心代码,原理就是在 webpack compiler 的 before-run 和 watch-run 事件钩子中去收集依赖然后附加到 webpack module.rule 的 include 上；收集的规则就是查找应用或者依赖包的 package.json 中声明的 compileDependencies 作为后编译依赖。
```
var util = require('./util')

function PostCompilePlugin (options) {
  // ...
}

PostCompilePlugin.prototype.apply = function (compiler) {
  var that = this
  compiler.plugin(['before-run', 'watch-run'], function (compiler, callback) {
    // ...
    var dependencies = that._collectCompileDependencies(compiler)
    if (dependencies.length) {
      var rules = compiler.options.module.rules
      rules && rules.forEach(function (rule) {
        if (rule.include) {
          if (!Array.isArray(rule.include)) {
            rule.include = [rule.include]
          }
          rule.include = rule.include.concat(dependencies)
        }
      })
    }
    callback()
  })
}
```
```
var PostCompilePlugin = require('webpack-post-compile-plugin')
// webpack.config.js
module.exports = {
  // ...
  module: {
    rules: [
      // ...
      {
        test: /\.js$/,
        loader: 'babel-loader',
        include: [
            resolve('src')
          ]
      },
      // ...
    ]
  },
  // ...
  plugins: [
    new PostCompilePlugin()
  ]
}
```
当前项目的 package.json 中添加 compileDependencies 字段来指定后编译依赖包
```
// app package.json
{
  // ...
  "compileDependencies": ["A", "B"]
  // ...
}
```
A 还有后编译依赖，所以需要在包 A 的 package.json 中指定 compileDependencies：
// A package.json
{
  // ...
  "compileDependencies": ["C", "D"]
  // ...
}
### 优点
公共的依赖可以实现共用，只此一份，重要的是只编译一次，建议通过 peerDependencies 管理依赖。
babel 转换 API（例如 babel-plugin-transform-runtime 或者 babel-polyfill）部分的代码只有一份。
不用每个依赖包都需要配置编译打包环节，甚至可以直接源码级别发布。
PS: 关于 babel-plugin-transform-runtime 和 babel-polyfill 的选择问题，对于应用而言，我们建议的是采用 babel-polyfill。因为一些第三方包的依赖会判断全局是否支持某些特性，而不去做 polyfill 处理。例如：vuex 会检查是否支持 Promise，如果不支持则会报错；或者说在代码中有类似 "foobar".includes("foo") 的代码的话 babel-plugin-transform-runtime 也是不能正确处理的
### 缺点
主应用的 babel 配置需要能兼容依赖包的 babel 配置。
依赖包不能使用 alias、不能方便的使用 DefinePlugin（可以经过一次简单编译，但是不做 babel 处理）。
应用编译时间会变长。
## 按需引入
后编译主要解决的问题是代码冗余，而按需引入主要是用来解决非必要的依赖的问题。按需引入针对的场景主要是组件库、工具类依赖包。因为不管是组件库还是依赖包，往往都是“大而全”的，而在开发应用的时候，我们可能只是使用了其一部分能力，如果全部引入的话，会有很多资源浪费。为了解决这个问题，我们需要按需引入。目前主流组件库或者工具包也都是提供按需引入能力的，但是基本都是提供对编译后模块引入。而我们推荐的是对源码的按需引入，配合后编译的打包方案。
## CSS代码压缩
CSS代码压缩使用css-minimizer-webpack-plugin，效果包括压缩、去重

代码的压缩比较耗时间，所以只用在打包项目时，所以只需要在webpack.prod.js中配置
```
// webpack.prod.js

const CssMinimizerPlugin = require('css-minimizer-webpack-plugin')

optimization: {
    minimizer: [
        new CssMinimizerPlugin(), // 去重压缩css
    ],
}
```
## JS代码压缩
JS代码压缩使用terser-webpack-plugin，实现打包后JS代码的压缩
```
// webpack.prod.js

const TerserPlugin = require('terser-webpack-plugin')

  optimization: {
    minimizer: [
      new CssMinimizerPlugin(), // 去重压缩css
      new TerserPlugin({ // 压缩JS代码
        terserOptions: {
          compress: {
            drop_console: true, // 去除console
          },
        },
      }), // 压缩JavaScript
    ],
  }
```
## tree-shaking
tree-shaking简单说作用就是：只打包用到的代码，没用到的代码不打包，而webpack5默认开启tree-shaking，当打包的mode为production时，自动开启tree-shaking进行优化
```
module.exports = {
  mode: 'production'
}
```
## source-map类型
source-map的作用是：方便你报错的时候能定位到错误代码的位置。它的体积不容小觑，所以对于不同环境设置不同的类型是很有必要的。
### 开发环境
开发环境的时候我们需要能精准定位错误代码的位置
```
// webpack.dev.js

module.exports = {
  mode: 'development',
  devtool: 'eval-cheap-module-source-map'
}
```

### 生产环境
生产环境，我们想开启source-map，但是又不想体积太大，那么可以换一种类型
```
// webpack.prod.js

module.exports = {
  mode: 'production',
  devtool: 'nosources-source-map'
}
```
## 打包体积分析

使用webpack-bundle-analyzer可以审查打包后的体积分布，进而进行相应的体积优化

只需要打包时看体积，所以只需在webpack.prod.js中配置

```
// webpack.prod.js

const {
  BundleAnalyzerPlugin
} = require('webpack-bundle-analyzer')

  plugins: [
    new BundleAnalyzerPlugin(),
]
```
# 用户体验优化

## 模块懒加载
如果不进行模块懒加载的话，最后整个项目代码都会被打包到一个js文件里，单个js文件体积非常大，那么当用户网页请求的时候，首屏加载时间会比较长，使用模块懒加载之后，大js文件会分成多个小js文件，网页加载时会按需加载，大大提升首屏加载速度

```
// src/router/index.js

const routes = [
  {
    path: '/login',
    name: 'login',
    component: login
  },
  {
    path: '/home',
    name: 'home',
    // 懒加载
    component: () => import('../views/home/home.vue'),
  },
]
```
## Gzip

开启Gzip后，大大提高用户的页面加载速度，因为gzip的体积比原文件小很多，当然需要后端的配合，使用compression-webpack-plugin

```
// webpack.prod.js

const CompressionPlugin = require('compression-webpack-plugin')

  plugins: [
    // 之前的代码...
    
    // gzip
    new CompressionPlugin({
      algorithm: 'gzip',
      threshold: 10240,
      minRatio: 0.8
    })
  ]

```
## 小图片转base64
对于一些小图片，可以转base64，这样可以减少用户的http网络请求次数，提高用户的体验。webpack5中url-loader已被废弃，改用asset-module

```
// webpack.base.js

{
   test: /\.(png|jpe?g|gif|svg|webp)$/,
   type: 'asset',
   parser: {
     // 转base64的条件
     dataUrlCondition: {
        maxSize: 25 * 1024, // 25kb
     }
   },
   generator: {
     // 打包到 image 文件下
    filename: 'images/[contenthash][ext][query]',
   },
},
```
## 合理配置hash
我们要保证，改过的文件需要更新hash值，而没改过的文件依然保持原本的hash值，这样才能保证在上线后，浏览器访问时没有改变的文件会命中缓存，从而达到性能优化的目的
```
// webpack.base.js

  output: {
    path: path.resolve(__dirname, '../dist'),
    // 给js文件加上 contenthash
    filename: 'js/chunk-[contenthash].js',
    clean: true,
  },
```