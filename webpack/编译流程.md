一.准备阶段merge webpack.config.js配置参数和shell命令参数

二.创建compiler对象阶段

compiler对象的constructor函数做的事情

1.获取webpck处理后的options
2.获取根路径的相对路径
3.创建plugin hooks
4.初始化
this.entries --- 入口模块
this.modules --- 依赖模块
this.chunks --- 所有的代码块
this.assets --- 存放本次产出的文件
this.files --- 本次编译所有产出的文件名

run函数做的事情

1.this.hooks.run.call()触发开始编译的plugin
2.获取入口配置对象
const entry = this.getEntry();
3.编译入口文件调用buildModule实现真正的模块编译逻辑
模块编译方法buildModule
(1). 读取文件原始代码
(2). 创建moduleCode为修改后的代码
(3). 调用loader进行处理对moduleCode做处理,获取所有传入的loader规则然后倒序执行loader传入源代码通过loader同步处理我的每一次编译的moduleCode
(4). 调用webpack 进行模块编译，获得最终的module对象，webpack对文件的处理
(1). 将当前模块相对于项目启动根目录计算出相对路径 作为模块ID2. (2).创建模块对象
const module = {
  id: moduleId,
  dependencies: new Set(), 
  // 该模块所依赖模块绝对路径地址
  name: [moduleName], // 该模块所属的入口文件
}
(3).调用babel分析我们的代码，当遇到require语句时，生成moduleId - 针对于跟路径的模块ID 添加进入新的依赖模块路径，通过babel修改源代码中的require变成__webpack_require__语句，
const alreadyModules = Array.from(this.modules).map((i) => i.id);
if (!alreadyModules.includes(moduleId)) {
// 为当前模块添加require语句造成的依赖(内容为相对于根路径的模块ID)
  module.dependencies.add(moduleId);
} else {
// 已经存在的话 虽然不进行添加进入模块编译 但是仍要更新这个模块依赖的入口
this.modules.forEach((value) => {
if (value.id === moduleId) {
    value.name.push(moduleName);
}
});
}
(4).递归依赖深度遍历,存在依赖模块则加入

三、加载插件注册插件中在不同时机想要对代码做的改动的hook