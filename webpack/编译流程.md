[编译流程图](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/19/16903d21fe18e5b8~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)
[编译流程详细图](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/851da6ae496d45b29e3897bd8282b691~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)
[原文链接](https://juejin.cn/post/7031546400034947108)
# 总结
1、初始化参数阶段。
这一步会从我们配置的webpack.config.js中读取到对应的配置参数和shell命令中传入的参数进行合并得到最终打包配置参数。

2、开始编译准备阶段
这一步我们会通过调用webpack()方法返回一个compiler方法，创建我们的compiler对象，并且注册各个Webpack Plugin。初始化一个相对于根路径的项目路径。


3、模块编译阶段
调用compiler.run()方法进行编译。从入口模块进行分析，调用匹配文件的loaders对文件进行处理。loader编译后进入webpack编译，通过babel编译分析模块依赖，为文件创建module对象将module依赖添加到module的dependences，递归dependences进行模块编译工作。


4、完成编译阶段

首先获取配置参数的输出配置(entries)，迭代this.chunks，将modules中的[name]替换称为对应的入口文件名称。同时根据chunks的内容为this.assets中添加需要打包生成的文件名和文件内容。将文件写入磁盘前调用plugin的emit钩子函数。将assets写入文件中后所有打包流程结束，触发webpack插件的done钩子。



# 一.准备阶段 -- merge webpack.config.js配置参数和shell命令参数

# 二.开始编译准备阶段

创建我们的compiler对象，初始化各种配置项到compiler对象中，并且注册各个Webpack Plugin。找到配置入口中的entry代码，调用compiler.run()方法进行编译。

## 1.获取根路径的相对路径
options.entry处理获得入口文件的绝对路径，然后统一通过this.rootPath是webpack保存的项目路径得到入口相对于这个实际上所有入口的路径都是基于这个rootPath的相对路径
## 2.获取webpack处理后的options并初始化compiler对象
## 3.创建compiler对象阶段 --- 创建compiler.[name].hooks
## 4.初始化内置对象
this.entries --- 入口模块
this.modules --- 依赖模块
this.chunks --- 所有的代码块
this.assets --- 存放本次产出的文件
this.files --- 本次编译所有产出的文件名
## 5.注册plugin的hooks，执行plugin的apply方法
# 三、模块编译阶段
## 1.run函数做的事情 --- 触发开始编译的plugin

此时我们通过this.hooks.beforeRun.callAsync执行关于beforeRun的所有tap监听方法，从而触发对应的plugin逻辑。
此时我们通过this.hooks.run.callAsync执行关于run的所有tap监听方法，从而触发对应的plugin逻辑。
beforeRun在run之前执行

## 2.new newCompilation 编译入口文件调用buildModule实现真正的模块编译逻辑
1.buildModule接受两个参数进行模块编译，第一个为模块所属的入口文件名称，第二个为需要编译的模块路径。
2.buildModule方法要进行代码编译的前提就是，通过fs模块根据入口文件路径读取文件源代码。
3.读取文件内容之后，调用所有匹配的loader对模块进行处理得到返回后的结果。
4.得到loader处理后的结果后，通过babel分析loader处理后的代码，进行代码编译。(这一步编译主要是针对require语句，修改源代码中require语句的路径)。
5.如果该入口文件没有依赖与任何模块(require语句)，那么返回编译后的模块对象。
6.如果该入口文件存在依赖的模块，递归buildModule方法进行模块编译。

### (一). fs读取文件原始代码
### (二). 创建moduleCode为修改后的代码
### (三). 调用loader进行处理对moduleCode做处理
#### 1、获取所有传入的loader规则
#### 2、然后倒序执行loader传入源代码
#### 3、通过loader同步处理我的每一次编译的moduleCode

### (四)、babel处理完文件后调用 webpack 进行模块编译，创建module对象
创建module对象，将文件内的require语句通过babel找到并且将require的文件路径变成相对于rootPath的相对路径并且将文件被当错entry的dependences添加进来。
```
const module = {
  id: moduleId, // 表示当前模块针对于this.rootPath的相对目录。
  dependencies: new Set(), // dependencies属性，它是一个Set内部保存了该模块依赖的所有模块的模块ID。
  // 该模块所依赖模块绝对路径地址
  name: [moduleName], // 它表示该模块属于哪个入口文件。
  _source: source，// 它存放模块自身经过babel编译后的字符串代码。
```
#### 使用babel处理完的code文件中使用__webpack_require__处理文件的dependences文件
当遇到require语句时，生成moduleId - 针对于跟路径的模块ID 添加进入新的依赖模块路径，通过babel修改源代码中的require变成__webpack_require__语句，递归深度遍历重复执行buildModule，将每一个编译后的模块保存进入this.modules中去。

**如果编译过的文件不会重新进入buildModule，只需要在编译过的module的name数组中加入两个引入它的父文件id即可**

# 四、编译完成

1、首先获取配置参数的输出配置(entries)，迭代module对象的chunks，将modules中的[name]替换称为对应的入口文件名称。同时根据chunks的内容为this.assets中添加需要打包生成的文件名和文件内容。

2、将文件写入磁盘前调用plugin的emit钩子函数。

3、判断output.path文件夹是否存在，如果不存在，则通过fs新建这个文件夹。

4、将本次打包生成的所有文件名(this.assets的key值组成的数组)存放进入files中去。

5、循环this.assets，将文件依次写入对应的磁盘中去。我们需要getSourceCode方法接受传入的chunk对象。从而返回该chunk的源代码。webpack打包后的代码仅仅只有入口文件和模块依赖是每次打包不同的地方，关于require方法之类都是相通的。因为我们最终实现的__webpack_require__方法全都是针对于模块跟路径的相对路径自己实现的require方法。

6、所有打包流程结束，触发webpack插件的done钩子。

**补充：在compiler.run方法中会调用compiler.compile方法执行compile、make、afterCompile等hooks**
