# 内存泄漏
内存泄漏就是指由于疏忽或者程序的某些错误造成**未能释放已经不再使用的内存的情况**

```
JavaScript的内存空间分为栈内存和堆内存，前者用来存放一些简单变量，后者用来存放复杂对象
简单变量指的是JS的基本数据类型，例如：String、Number、Boolean、null、undefined、Symbol、BigInt
复杂对象指的是JS的引用数据类型，例如：Object、Array、Function

```

# 变量存储
## 栈
栈存储基础类型,存储和使用方式后进先出,存储引用类型的变量，但实际上保存的不是变量本身，而是指向该对象的指针(在堆内存中存放的地址)。

所有方法中定义的变量存在栈中，方法执行结束，这个方法的内存栈也自动销毁可以递归调用方法，这样随着栈深度增加，JVW维持一条长长的方法调用轨迹，内存不够分配，会产生栈溢出。

自动分配内存空间，自动释放，占固定大小的空间
## 堆
存储引用类型：Object（Function/Array/Date/RegExp)，动态分配内存空间，大小不定也不会自动释放，堆内存中的对象不会因为方法执行结束就销毁，因为有可能被另一个变量引用(参数传递等)。

## 为什么会有栈和堆之分
通常与垃圾回收机制有关。每一个方法执行时都会建立自己的内存栈，然后将方法里的变量逐个放入这个内存栈中，随着方法执行结束，这个方法的内存栈也会自动销毁。为了使程序运行时占用的内存最小，栈空间都不会设置太大，而堆空间则很大。每创建一个对象时，这个对象会被保存到堆中，以便反复复用，即使方法执行结束，也不会销毁这个对象，因为有可能被另一个变量(参数传递等)引用，直到对象没有任何引用时才会被系统的垃圾回收机制销毁。而且JS引擎需要用栈来维护程序执行期间上下文的状态，如果所有的数据都在栈里在，栈空间大了的话，会影响到上下文切换的效率，进而影响整个程序的执行效率。
# 垃圾回收机制
JS具有自动垃圾回收机制，会定期对无效变量进行回收

## 引用计数法

当我们用一个变量指向一个值时，就创建了一个针对这个值的 “引用”,在引用计数法的机制下，内存中的每一个值都会对应一个引用计数。当垃圾收集器感知到某个值的引用计数为0时，就会将它的内存释放掉。

### 缺点

无法判断循环引用场景下的 “垃圾”，这也是它退出历史舞台的原因。需要一个计数器，而此计数器需要占很大的位置

### 优点

首先引用计数在引用值为 0 时，也就是在变成垃圾的那一刻就会被回收，所以它可以立即回收垃圾。而标记清除算法需要每隔一段时间进行一次，那在应用程序（JS脚本）运行过程中线程就必须要暂停去执行一段时间的 GC，另外，标记清除算法需要遍历堆里的活动以及非活动对象来清除，而引用计数则只需要在引用时计数就可以了。

## 标记清除法

在标记清除算法中，根据变量是否可抵达，来决定是否清除。这个算法有两个阶段，分别是标记阶段和清除阶段

### 标记阶段
垃圾收集器会先找到根对象，从根对象出发，扫描所有可以通过根对象触及的变量，这些变量会被标记为 “可抵达”

### 清除阶段
没有被标记为 “可抵达” 的变量，就会被清除

### 优点
实现比较简单，打标记也无非打与不打两种情况，这使得一位二进制位（0和1）就可以为其标记，非常简单。

### 缺点
标记清除算法有一个很大的缺点，就是在清除之后，剩余的对象内存位置是不变的，也会导致空闲内存空间是不连续的，出现了内存碎片。并且由于剩余空闲内存不是一整块，它是由不同大小内存组成的内存列表，这就牵扯出了内存分配的问题。

假设我们新建对象分配内存时需要大小为 size，由于空闲内存是间断的、不连续的，则需要对空闲内存列表进行一次单向遍历找出大于等于 size 的块才能为其分配，那如何找到合适的块呢？我们可以采取下面三种分配策略：

* First-fit，找到大于等于 size 的块立即返回

* Best-fit，遍历整个空闲列表，返回大于等于 size 的最小分块

* Worst-fit，遍历整个空闲列表，找到最大的分块，然后切成两部分，一部分 size 大小，并将该部分返回

这三种策略里面 Worst-fit 的空间利用率看起来是最合理，但实际上切分之后会造成更多的小块，形成内存碎片，所以不推荐使用，对于 First-fit 和 Best-fit 来说，考虑到分配的速度和效率 First-fit 是更为明智的选择。


## v8对垃圾回收的优化---新生代和老生代

V8实现了GC算法，采用了分代式垃圾回收机制，所以V8将堆内存分为新生代(副垃圾回收器)和老生代(主垃圾回收器)两个部分

### 新生代

新生代中通常只支持1~8M的容量，所以主要存放生存时间较短的对象。将新生代空间分为两个区域：对象区域和空闲区域。

[image](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fc1391485c840bdbede249e4fdd6058~tplv-k3u1fbpfcp-watermark.awebp)

将新分配的对象存入对象区域中，当对象区域存满了，就会启动GC算法。对对象区域内的垃圾做标记，标记完成之后将对象区域中还存活的对象复制到空闲区域中，已经不用的对象就销毁。这个过程不会留下内存碎片。复制完成后，再将对象区域和空闲互换。既回收了垃圾也能让新生代中这两块区域无限重复使用下去

### 老生代

老生代特点就是占用空间大，所以主要存放存活时间长的对象。老生代中使用标记清除算法和标记压缩算法。因为如果也采用Scavenge GC算法的话，复制大对象就比较花时间了标记清除在以下情况下会先启动标记清除算法。标记清除的流程是这样的从根部(js的全局对象)出发，遍历堆中所有对象，然后标记存活的对象。标记完成后，销毁没有被标记的对象


## 减少垃圾回收
虽然浏览器可以进行垃圾自动回收，但是当代码比较复杂时，垃圾回收所带来的代价比较大，所以应该尽量减少垃圾回收。

### 优化方法

1.对数组进行优化：通过将数组的长度设置为0，以此来清空数组	//如果给数组赋值为[]，会同时会创建一个新的空对象
2.对对象进行优化： 对象尽量复用，对于不再使用的对象，就将其设置为null，尽快被回收
3.生命周期清除
4.使用WeakMap、WeakSet

## 内存泄漏的情况

### 意外的全局变量

第一种
```
function foo(arg) {
    bar = "this is a hidden global variable";
}
bar没被声明,会变成一个全局变量,在页面关闭之前不会被释放。
```
第二种
```
另一种意外的全局变量可能由 this 创建:
function foo() {
    this.variable = "potential accidental global";
}
// foo 调用自己，this 指向了全局对象（window）
foo();
复制代码在 JavaScript 文件头部加上 'use strict'，可以避免此类错误发生。启用严格模式解析 JavaScript ，避免意外的全局变量。
```

### 被遗忘的计时器或回调函数

### 闭包

### 没有清理的DOM元素引用
```
var elements = {
    button: document.getElementById('button'),
    image: document.getElementById('image'),
    text: document.getElementById('text')
};
function removeButton() {
    document.body.removeChild(document.getElementById('button'));
}
```
虽然我们用removeChild移除了button，但是还在elements对象里保存着#button的引用，换言之，DOM元素还在内存里面。

```

<div id="root">
  <ul id="ul">
    <li></li>
    <li></li>
    <li id="li3"></li>
    <li></li>
  </ul>
</div>
<script>
  let root = document.querySelector('#root')
  let ul = document.querySelector('#ul')
  let li3 = document.querySelector('#li3')
  
  // 由于ul变量存在，整个ul及其子元素都不能GC
  root.removeChild(ul)
  
  // 虽置空了ul变量，但由于li3变量引用ul的子节点，所以ul元素依然不能被GC
  ul = null
  
  // 已无变量引用，此时可以GC
  li3 = null
</script>

```

```
<div id="my-div">
  <span>My Div</span>
  <ul>
    <li>Hero</li>
    <li>Cows</li>
    <li>Bugs</li>
  </ul>
</div>

<button onclick="deleteMyDiv()">Delete My Div</button>
<script>
const myDiv = document.querySelector('#my-div')

function deleteMyDiv () {
  myDiv.parentElement.removeChild(myDiv)
}
</script>

点击 "Delete My Div" 按钮时，节点 #my-div 不会消失

function getMyDiv () {
  return document.querySelector('#my-div')
}

function deleteMyDiv () {
  const myDiv = getMyDiv()
  myDiv.parentElement.removeChild(myDiv)
}

```
