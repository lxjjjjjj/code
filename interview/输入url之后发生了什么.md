# 总结DOM Tree加载渲染和CSS文件加载、JS文件加载执行的结论

[原文链接](https://juejin.cn/post/7017807404645482504)

[v8执行细节](https://juejin.cn/post/7038962067453263886#heading-7)

[浏览器渲染流程图](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d33869c017bd4525a25632ef61fcbee4~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)
- js执行浏览器会被js引擎"霸占"，从而导致渲染进程无法执行阻塞DomTree的渲染的
- css加载并不会阻塞Dom Tree的构建
- css加载会阻塞Dom Tree的渲染，也就是Render Tree的生成
- 位于css代码之前的js代码加载执行是毫无疑问的，但位于css加载之后的代码，css代码的加载是会阻塞后续js代码的执行的。
- HTML和Css的加载其实他们是并行加载，这也就印证了我们上边提到的css加载并不会影响Dom Tree的构建。
- 同时浏览器的渲染引擎和js的解释引擎他们是互斥的，也就是说css加载和dom加载都会和js执行加载互斥的。(当然排除scirpt标签上的defer和async)属性。
- 关于第二点，css的加载并不会阻塞Dom Tree的构建，但是如果在css文件之后存在js脚本，js是会阻塞dom tree的构建的，因为css加载阻塞了js执行，所以间接的阻塞了dom tree的构建。

# js脚本的defer
这是html中的head标签中加载两个脚本的顺序，js文件引用了defer属性。所谓**defer意思是说js的加载会异步执行并不会阻塞后续加载**，**按照加载顺序在文档完成解析后，DomContentLoaded事件前依次执行对应加载完成的js脚本**。有关defer详细信息你可以在这里看到所谓的DomContentLoaded事件，当初始的 HTML文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完全加载。你可以理解成为**当Dom Tree构建完成后就会触发DomContentLoaded事件。此时也就是说我们的script脚本会异步加载等待Dom Tree解析完毕后,DOMContentLoaded事件调用前进行执行。**

# 案例

当我们的js加载快于css加载13ms完成。当js加载完成后css还在请求download中，此时由于dom Tree已经构建完毕符合我们js的执行时机,所以此时js优先于css执行完成。当我们执行js时页面上并不存在任何样式，此时我们通过getBoundingClientRect获取的值自然是不正确的。由于defer脚本已经完成，所以在css加载过程中其实线程是空虚的，所以此时js引擎会执行加载完成的defer脚本进行执行。造成js提前与css执行完毕。

所以会存在在useEffect中获取dom元素的位置会导致位置是随机值，解决办法就是用window.onload中获取位置。

# onload和DOMContentLoaded区别

DOMContentLoaded

```
当初始 HTML 文档完全加载和解析时触发该DOMContentLoaded事件，无需等待样式表、图像和子框架完成加载。
```

```
const log = document.querySelector('.event-log-contents');
const reload = document.querySelector('#reload');

reload.addEventListener('click', () => {
  log.textContent ='';
  setTimeout(() => {
    window.location.reload(true);
  }, 200);
});

window.addEventListener('load', (event) => {
  log.textContent += 'load\n';
});

document.addEventListener('readystatechange', (event) => {
  log.textContent += `readystate: ${document.readyState}\n`;
});

document.addEventListener('DOMContentLoaded', (event) => {
  log.textContent += 'DOMContentLoaded\n';
});

// readystate: interactive
// DOMContentLoaded
// readystate: complete
// load
```
load

load 事件在整个页面及所有依赖资源如样式表和图片都已完成加载时触发。它与 DOMContentLoaded 不同，后者只要页面 DOM 加载完成就触发，无需等待依赖资源的加载。

# 浏览器中的进程

- 浏览器进程
- 插件进程
- GPU进程
- 网络进程
- 渲染进程（GUI渲染线程、JS引擎线程、事件触发线程）


```
浏览器进程: 你可以理解浏览器进程为一个统一的"调度大师"去调度其他进程，比如我们在地址栏输入url时，浏览器进程首先会调用网络进程。 它可以做一些子进程管理以及一些存储的处理。


渲染进程: 这个进程对于我们来说是最重要的一个进程，每一个tab页都拥有独立的渲染进程，它的主要作用是渲染页面。


网络进程: 这个进程是控制对于一些静态资源的请求，它将资源请求完成之后会交给渲染进程进行渲染。


GPU进程: 这个进程可以调用硬件进行渲染，从而实现渲染加速。比如translate3d等css3属性会骗取调用GPU进程从而开启硬件加速。


插件进程: chrome中的插件也是一个独立的进程。

```
# 页面渲染进程

```
1.浏览器通过请求得到一个 HTML文本
2.渲染进程解析 HTML 文本，构建 DOM 树
3.浏览器解析 HTML 的同时，如果遇到内联样式或者样本样式，则下载并构建样式规则（stytle rules）。若遇到 Javascript 脚本，则会下载并执行脚本
4.DOM 树和样式规则构建完成之后，渲染进程将两者合并成渲染树（render tree）
5.渲染进程开始对渲染树进行布局，生成布局树（layout tree）
6.渲染进程对布局树进行绘制，生成绘制记录
7.渲染进程对布局树进行分层，分别栅格化每一层并得到合成帧
8.渲染进程将合成帧发送给 GPU 进程将图像绘制到页面中

```
[react官网的渲染优化](https://juejin.cn/post/7128369638794231839)
# 从输入URL到页面显示之间究竟发生了什么

当我们在地址栏中输入了一个url时，浏览器进程会监听到这次交互。紧接着它会分配出一个渲染进程进行准备渲染页面，同时浏览器进程会调用网络进程加载资源。等待网络进程加载完成资源后会将资源交给渲染进程进行页面的渲染

[浏览器渲染](https://juejin.cn/post/7022995756160122888)
##### 在网络协议七层模型中

1.通常我们会将应用层、表示层、会话层统称为应用层,应用层的主要协议就是HTTP协议。

2.传输层中我们浏览器中Http协议是基于tcp去进行网络传输。(常见传输协议的有tcp还有udp)

3.网络层中一般都是ip协议。

4.当然在数据链路层和物理层都是被称为物理层。

1.首先当我们输入url输入一个域名浏览器会在磁盘/内存缓存中去查找请求的文件，查看是否命中缓存。如果命中缓存则直接会直接从缓存中拿取对应的ip地址。如果命中强缓存则会直接返回对应资源不会进入下面的步骤。

2.假设我们是首次访问这个页面，此时并没有任何缓存:如果我们访问的这个域名没有被解析过，那么我们需要解析地址栏中输入的域名。解析域名主要依靠的是DNS协议，将域名解析成为ip地址。ip地址才是真正找到对应的ip。dns你可以理解它为一个映射表，将域名和ip地址进行了映射。其实就是一个分布式的数据库，通过域名查找对应的ip地址。需要注意的是dns解析是基于udp协议的而非tcp。


3.此时会根据DNS解析通过域名+端口号解析出对应的IP地址。
我们拥有了ip地址之后，接下来我们就需要将利用ip进行寻找网页地址。
此时如果我们的请求地址是https，在通过ip寻址之前会额外增加一步ssl协商保证数据的安全性。
当通过ip寻址成功后，浏览器知道了服务器的地址。此时并不会立即将数据发送过去，而是会进入一个排队等待的过程。比如一个域名下有多个请求，同一个域名在http1.1下最多只能建立6个tcp链接，也就是说同一时间最多发送6个请求，他们首先会进入一个排队的等待时间。
排队结束后，开始发送请求。此时就要通过tcp先进行创建链接通过三次握手，建立完成链接之后开始传输数据。
上边我们说过tcp是基于分段传输的，基于内容特别大的传输内容tcp会将数据包进行拆分称为多个数据包进行有序传输。

在tcp传输过程中如果传输中出现了丢包，那么tcp会进行重发。服务器再收到之后会按照顺序进行接收。
tcp建立完成链接之后，浏览器会通过http请求发送请求的数据。
一次http请求包含

请求行
请求头
请求体

在http1.1中默认开启了了Connection:keep-alive，它的作用是在下次发送请求时在一定时间内可以复用上一次的tcp链接而不需要重新建立这个链接。(也就是在一定时间内保持相同域名tcp链接不断开)。
此时服务器时候收到请求发送的数据，根据请求行，请求头，请求体进行解析。解析完成后返回响应行、响应头、响应体。

注意：这里服务器返回状态码中有一些特殊的状态码


301/302这两个状态码都表示重定向，如果返回这两个任意一个就会根据返回头中的Location返回的域名重新进行上边的一系列操作。


304状态码表示告诉浏览器本次资源走缓存而不会重新请求下载资源。


这个过程便是一个最基础的浏览器针对一个url访问网络请求的过程。


有兴趣的朋友可以自己尝试输入一下，这里当我们输入http://taobao.com/浏览器会解析DNS以及TCP三次握手建立连接然后发送请求，当得到响应后发现Response Status是302它会根据返回的Location重定向到http://www.taobao.com/。
之后我们去重定向到http://www.taobao.com/,请求得到访问又是301状态码，于是有被重新重定向https://taobao.com/上。
然后再次进行DNS解析，Tcp建立连接这个步骤。。

建议大家在新的无痕浏览页中去进行这些操作，我们排除掉DNS缓存以及任何浏览器缓存的干扰机制去看结果会更加纯粹。

这里我们已经大概领略到了重定向域名的访问，我们可以发现每一次重定向都会重新进行DNS解析以及TCP连接的建立是非常耗时的。所以在我们的真实项目中要尽量的避免进行资源重定向，如果有存在重定向的资源尽量还是将它直接替换成新的地址连接。
接下来我们以第三次https://www.taobao.com/这次请求为例来分析一下一次请求（无任何缓存）的各个阶段:

4.
##### 为什么dns解析是基于udp而非tcp协议
我们的dns解析过程是一个服务器的查找过程。因为域名分为一级/二级...域名，所以每一级域名都会迭代去查询如果它采用tcp协议的话，每经过一次域名查询，域名服务器都会经过三次握手。 如果是基于tcp协议进行域名查找的话每一次tcp协议都会进行三次握手。但是udp就不会，他会直接发包然后确认。

相较于udp，tcp是更加安全，可靠的(因为三次握手以及四次挥手)但是这也造成了它相对于udp消耗更多时间。
udp常用的场景是视频或者直播中，对于我们来说dns解析中使用udp更多的原因是因为udp的速度，当然即使丢包了，我们重新发送就可以了。tcp传输的过程称为分段传输，也就是会拆分为多个包，一个包一个包的进行发送得到响应之后在发送下一个包。这样的方式无疑带来的有点是更加可靠和安全。但是在时效上并不如udp协议的实时(直接通信无需建立连接)。

