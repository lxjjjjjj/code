[原文链接](https://juejin.cn/post/6903119693742080007)
1. setup函数其实是一个生命周期钩子，它对应的其实就是Vue2中的beforeCreate和create，并且他是vue3的composition API的入口函数。
   
2. 在vue3中我们通过这个函数来定义vue2中的data,methods,watch,computed属性
   
3. setup函数必须有返回值，必须返回一个对象，对象里包含所有在template模板中需要使用到的属性（包含data,methods等）
   
4. 在setup里面通过ref生命的响应式数据，去取值或者赋值的时候必须通过**.value的方法去拿，但是template却不需要使用.value**
5. ref也可以调用原生dom
   
6. setup接收第一个参数是props，用于接收props，也就是定义在组件上的属性（同vue2),但是接收的props必须先在props属性中定义，否则是不会被接收到的
   
7. setup接收的第二个参数是context,在js里面这个形参代表了上下文，它暴露组件的 property，他就是一个普通的javaScript对象，在这里面我们可以取到attrs,** slots**,** emit**，等属性，所以可以干嘛我想各位都知道了。

8. ！需要注意的是，props是响应式的数据，你不能使用 ES6 解构，因为它会消除 prop 的响应性。我们可以尝试一下将 props 进行 ES6 解构，会发现控制台报警了，所以，要结构props需要用到setup 函数中的 toRefs 来安全地完成此操作，后面再来说这个函数。

9. 如果不习惯ref的value调用可以改成reactive的方式调用
    [reactive的调用方式](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7811128c9a14676aa8f0fb03f3df467~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image)
    箭头指出了不一样的地方，可以为大家总结下面几点

    不再使用ref对属性进行申明响应式，而是和类似vue2的写法，我只需要定义一个data对象即可，想要的属性都放在data，最后统一返回data即可。
    不再使用**.value的方式而改用data.**这样的方式，更方便自己理解，当然同理，template也需要加上，对我个人而言，，我觉得这种的写法更为清晰，更好理解。
    不需要再return一堆东西了，只需要return一个对象就可以了，写法更加简洁。

    ！这时候又有同学会问了，本来template不需要使用**.value怎么现在反而需要加data.了，这不是更麻烦了么？可以不去在template**加其他东西而直接使用属性就可以么？  当然可以。

    需要做到这种，有同学就会想到，只要我不返回对象，返回所以属性不就可以了吗？你想的没错，直接return所以属性就行了，就可以实行了，但是怎么实现呢？

    有同学就会想，直接结构赋值不就好了吗，直接rerurn {...data}这样不就可以么？我可以直接告诉你，这样不可以，那么是为什么呢，这里和上面的props一样的原理，因为我们定义的是响应式的数据，如果直接这样结构赋值就会造成，响应式特性的破坏，造成数据不再是响应式，这样点击按钮就没有任何变化了，所以我们不可以这样做。
    那么我们如何实现呢？也很简单，使用官方提供的 **toRefs()**函数即可完成，我们再来改造一下。

10. toRefs()函数对reavtive()函数解构返回
    使用这样的方式就可以在模板中直接使用了。不难想象这个方法就是为了通过其方法结构后不去破坏他的响应式特性，就是这么简单。

11. Vue3的模块化
    我们在使用vue2项目中，如果复用某些功能，我们会采用mixin的方式进行混入，而在vue3中，新的模块儿化的重用机制将会更加便捷，我们先来写一个简单的实时在线的时间显示功能，如下：

    就是点击按钮触发一个时间显示的功能非常的简单，页面效果就是这样，相信同学们，都能轻松理解：

    现在我们想要复用这段逻辑，在vue2中，如果我们采用mixin混入式的方式开发将要复用很大一部分代码逻辑，让我们看看如果vue3想要复用这个功能需要干嘛吧：

    第一步我们只需要把**setup()**里面我们写的这一段逻辑提取到一个ts文件即可，然后导出我们需要的方法和属性，我在这里直接导出了一个ref()包裹的对象，如果你想更细致，也可以导出data在组件中进行ref()包裹响应，而在用的时候非常简单，看看下图：

    我们可以看到，只需两部就完成了，只需要引入，再在**setup()**中直接return，就完成了一个功能的复用

    可以说，vue3在模块复用性这里相对于vue2有了非常大的提升，这样的改变会使的组件之间的模块儿化变得异常的灵活，这样的写法你是否很期待呢？

12. Teleport翻译过来就是瞬移的意思，于是，国内翻译过来就是瞬移组件的，怎么来理解这个瞬移组件呢。

    我们都知道的一点是，不论是vue或者是react在入口文件的html地方，都只有一个容器就是<div id='app'></div>，我们称之为入口，同时页面上的所有组件实际都是挂载在这个节点的，打开网页，我们可以看到控制到上，最外层只有有个节点就是这个app。
    写过弹窗组件或者消息提示组件的朋友们都知道，像这种全局只有一个状态的组件，我们不希望他混入我们的组件中，我们希望他独立于app组件，所以，在大多数优秀的ui框架中，这一类的高级组件，一般会去采用新创建一个节点的方式，抽离出app节点，这样更为容易控制，并且在使用完毕后即使的删除。那么Teleoirt组件实际上就是这样的一个东西，可以独立于app之外的新的节点，我们都知道入口文件index.html都有一个节点叫app，我们新增一个app2，如图。

    然后我们怎么使用这个节点呢，我们先去创建一个简易的弹窗组件，这个组件也很简单，在页面中心展示出来就好，我们来看看这个组件和vue2有何区别吧：

    我们可以看到，这个组件外部包裹了一层Teleport标签，并且拥有一个to属性，那么首先，要使用瞬移组件就需要，这个标签包裹，那么to属性呢就代表我要挂载在哪个节点，如上图，我们创建了一个app2的节点，我们想要挂载在这个节点上面，我们to='app2'就可了，这样就创建了一个瞬移组件，使用方法和vue2没有任何区别，我们来看看实际效果吧：

    ok，就是这么简单，就完成了一个瞬移组件的创建，这样的组件在对于一些状态单一的组件创建中，变得更加丝滑了，不会对使用的组件内部造成任何破坏，也不会出现样式污染等各类问题，非常的实用。

13. Vue3的异步请求组件Suspense
    这个异步组件(Suspense)呢是vue3新加的一种组件，再日常的开发中，异步组件是不可缺少的一部分，例如接口请求，图片请求，各种异步操作所导致的请求都属于异步组件，在vue2中这些状态的判断都需要我们自己手动去判断，但是vue3提供这一非常贴心的组件，这个中文翻译过来就是悬念的意思，他提供了两个template 也就是两个插槽，一个是没请求回来的时候显示什么，一个是请求成功显示什么，我们来写一个看看吧，先来写个异步的组件，非常简单，这里的这个接口是一个随机返回一张图片的接口。

    这里呢就是随机返回一个图片，我们来引入这个组件使用吧：

    使用非常简单，通过Suspense标签包裹的组件就是异步组件，在其中，提供了两个插槽，分别是成功和失败的插槽，会对应显示其中的内容，这样的写法可以方便我们少做很多冗余的判断，是不是也很好用呢

14. vue3的watch的变化和watchEffect()
    watch侦听器，我们已经很常见了，基础用法就是监听一个值的新旧值的变化，在vue2里面采用的是一个对象的形式，然后在里面去监听不同的值，在vue3已经发生了改变，让我们一起来看看
    
    import {watch} from 'vue'

    watch(a, (newVal, oldVal) => {
        console.log(newVal, '===', oldVal)
    })

    可以看到vue3的watch基础用法已经改变，想要使用watch，必须先引入，然后实际上，vue3现在的语法和各类ui框架的按需引入一样，每个API都是要用什么引入什么这样的方式，后面我们再来看看这样的好处
    然后看看语法，这里的wacth函数接收两个参数，第一个参数是我们要检测的值，第二个是回调函数，和以前一样拥有新旧两个值。
    那么同时，vue3的watch支持同时监听多个值，以数组的形式，如下：
    import {watch} from 'vue'

    watch([a, b], ([newValA, newValB], [oldValA, oldValB]) => {
        console.log(newValA, newValB, '===', oldValA, oldValB)
    })

    监听多个值，对应的回调函数的形参里的新旧值就也是多个，这样的监听会让我们的业务做某些对比判断的时候更加的灵活，上面就是vue3的watch的基本用法了，当然，还有一个地方需要特别注意的是。

    watch只能监听通过**ref()方法定义的响应式数据，通过reactive()**函数定义的将会直接报错，让我们先来看看报的错误再来说说为什么：

    上面这段报错是什么意思呢？  它告诉我们，watch只能监听，1：拥有getter/setter属性的值。2：一个ref属性，也就是通过**ref()申明的数据。3：一个reactive()**函数返回的对象。4：一个数组，这四种方式，那么就如上图，data.selectPeople会直接报错，就是因为我们监听这个值不属于上面四种情况，

    那么首先我们想为很么需要做呢？为什么不可以监听呢？我们先想想vue2中watch有一个属性叫deep深度监听，这又是为什么呢？那么深度监听的本质其实是为了解决循环引用问题，那么我们知道，vue2的深度监听实际上是用了递归来解决，这样就造成了性能不是很好，所以官方也不是很推荐使用deep，那么上面的问题就是，当你去监听一个对象或者数组的时候，前后对象就是循环引用，会发现newVal和oldVal的值始终一样，所以，才会出现上面这种情况，所以，要想解决上面的问题也很简单，可以通过一个函数直接return回来一个新值，这样就可以解决引用问题，如下

    相比之下，vue3的watch不论是从语法或者是从业务考虑，都有了新的场景和更多的使用方法，变得更加灵活了。
    watchEffect呢也是vue3提出的一个新的API，语法是这样的：
    import {watchEffect} from 'vue'
    watchEffect(() => console.log(name))

    他是一个方法，接收一个回调函数，他不需要去指定监听谁，它会去自动收集依赖，只要在回调函数中使用了的属性，在发生变化的时候，都会去触发这个回调函数，这样就会变得非常简单，在业务中，我们不必去特意的监听某某属性，而是直接把他写在其回调函数中，就可以自动帮我们收集依赖了。







