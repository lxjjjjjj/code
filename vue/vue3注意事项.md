1. setup函数其实是一个生命周期钩子，它对应的其实就是Vue2中的beforeCreate和create，并且他是vue3的composition API的入口函数。
   
2. 在vue3中我们通过这个函数来定义vue2中的data,methods,watch,computed属性
   
3. setup函数必须有返回值，必须返回一个对象，对象里包含所有在template模板中需要使用到的属性（包含data,methods等）
   
4. 在setup里面通过ref生命的响应式数据，去取值或者赋值的时候必须通过**.value的方法去拿，但是template却不需要使用.value**
5. ref也可以调用原生dom
   
6. setup接收第一个参数是props，用于接收props，也就是定义在组件上的属性（同vue2),但是接收的props必须先在props属性中定义，否则是不会被接收到的
   
7. setup接收的第二个参数是context,在js里面这个形参代表了上下文，它暴露组件的 property，他就是一个普通的javaScript对象，在这里面我们可以取到attrs,** slots**,** emit**，等属性，所以可以干嘛我想各位都知道了。

8. ！需要注意的是，props是响应式的数据，你不能使用 ES6 解构，因为它会消除 prop 的响应性。我们可以尝试一下将 props 进行 ES6 解构，会发现控制台报警了，所以，要结构props需要用到setup 函数中的 toRefs 来安全地完成此操作，后面再来说这个函数。

9. 如果不习惯ref的value调用可以改成reactive的方式调用
    [reactive的调用方式](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7811128c9a14676aa8f0fb03f3df467~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image)
    箭头指出了不一样的地方，可以为大家总结下面几点

    不再使用ref对属性进行申明响应式，而是和类似vue2的写法，我只需要定义一个data对象即可，想要的属性都放在data，最后统一返回data即可。
    不再使用**.value的方式而改用data.**这样的方式，更方便自己理解，当然同理，template也需要加上，对我个人而言，，我觉得这种的写法更为清晰，更好理解。
    不需要再return一堆东西了，只需要return一个对象就可以了，写法更加简洁。

    ！这时候又有同学会问了，本来template不需要使用**.value怎么现在反而需要加data.了，这不是更麻烦了么？可以不去在template**加其他东西而直接使用属性就可以么？  当然可以。

    需要做到这种，有同学就会想到，只要我不返回对象，返回所以属性不就可以了吗？你想的没错，直接return所以属性就行了，就可以实行了，但是怎么实现呢？

    有同学就会想，直接结构赋值不就好了吗，直接rerurn {...data}这样不就可以么？我可以直接告诉你，这样不可以，那么是为什么呢，这里和上面的props一样的原理，因为我们定义的是响应式的数据，如果直接这样结构赋值就会造成，响应式特性的破坏，造成数据不再是响应式，这样点击按钮就没有任何变化了，所以我们不可以这样做。
    那么我们如何实现呢？也很简单，使用官方提供的 **toRefs()**函数即可完成，我们再来改造一下。

10. toRefs()函数对reavtive()函数解构返回
    使用这样的方式就可以在模板中直接使用了。不难想象这个方法就是为了通过其方法结构后不去破坏他的响应式特性，就是这么简单。




