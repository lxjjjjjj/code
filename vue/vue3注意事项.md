[原文链接](https://juejin.cn/post/6903119693742080007)
1. setup函数其实是一个生命周期钩子，它对应的其实就是Vue2中的beforeCreate和create，并且他是vue3的composition API的入口函数。
   
2. 在vue3中我们通过这个函数来定义vue2中的data,methods,watch,computed属性
   
3. setup函数必须有返回值，必须返回一个对象，对象里包含所有在template模板中需要使用到的属性（包含data,methods等）
   
4. 在setup里面通过ref生命的响应式数据，去取值或者赋值的时候必须通过**.value的方法去拿，但是template却不需要使用.value**
5. ref也可以调用原生dom
   
6. setup接收第一个参数是props，用于接收props，也就是定义在组件上的属性（同vue2),但是接收的props必须先在props属性中定义，否则是不会被接收到的
   
7. setup接收的第二个参数是context,在js里面这个形参代表了上下文，它暴露组件的 property，他就是一个普通的javaScript对象，在这里面我们可以取到attrs,** slots**,** emit**，等属性，所以可以干嘛我想各位都知道了。

8. ！需要注意的是，props是响应式的数据，你不能使用 ES6 解构，因为它会消除 prop 的响应性。我们可以尝试一下将 props 进行 ES6 解构，会发现控制台报警了，所以，要结构props需要用到setup 函数中的 toRefs 来安全地完成此操作，后面再来说这个函数。

9. 如果不习惯ref的value调用可以改成reactive的方式调用
    [reactive的调用方式](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7811128c9a14676aa8f0fb03f3df467~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image)
    箭头指出了不一样的地方，可以为大家总结下面几点

    不再使用ref对属性进行申明响应式，而是和类似vue2的写法，我只需要定义一个data对象即可，想要的属性都放在data，最后统一返回data即可。
    不再使用**.value的方式而改用data.**这样的方式，更方便自己理解，当然同理，template也需要加上，对我个人而言，，我觉得这种的写法更为清晰，更好理解。
    不需要再return一堆东西了，只需要return一个对象就可以了，写法更加简洁。

    ！这时候又有同学会问了，本来template不需要使用**.value怎么现在反而需要加data.了，这不是更麻烦了么？可以不去在template**加其他东西而直接使用属性就可以么？  当然可以。

    需要做到这种，有同学就会想到，只要我不返回对象，返回所以属性不就可以了吗？你想的没错，直接return所以属性就行了，就可以实行了，但是怎么实现呢？

    有同学就会想，直接结构赋值不就好了吗，直接rerurn {...data}这样不就可以么？我可以直接告诉你，这样不可以，那么是为什么呢，这里和上面的props一样的原理，因为我们定义的是响应式的数据，如果直接这样结构赋值就会造成，响应式特性的破坏，造成数据不再是响应式，这样点击按钮就没有任何变化了，所以我们不可以这样做。
    那么我们如何实现呢？也很简单，使用官方提供的 **toRefs()**函数即可完成，我们再来改造一下。

10. toRefs()函数对reavtive()函数解构返回
    使用这样的方式就可以在模板中直接使用了。不难想象这个方法就是为了通过其方法结构后不去破坏他的响应式特性，就是这么简单。

11. Vue3的模块化
    我们在使用vue2项目中，如果复用某些功能，我们会采用mixin的方式进行混入，而在vue3中，新的模块儿化的重用机制将会更加便捷，我们先来写一个简单的实时在线的时间显示功能，如下：

    就是点击按钮触发一个时间显示的功能非常的简单，页面效果就是这样，相信同学们，都能轻松理解：

    现在我们想要复用这段逻辑，在vue2中，如果我们采用mixin混入式的方式开发将要复用很大一部分代码逻辑，让我们看看如果vue3想要复用这个功能需要干嘛吧：

    第一步我们只需要把**setup()**里面我们写的这一段逻辑提取到一个ts文件即可，然后导出我们需要的方法和属性，我在这里直接导出了一个ref()包裹的对象，如果你想更细致，也可以导出data在组件中进行ref()包裹响应，而在用的时候非常简单，看看下图：

    我们可以看到，只需两部就完成了，只需要引入，再在**setup()**中直接return，就完成了一个功能的复用

    可以说，vue3在模块复用性这里相对于vue2有了非常大的提升，这样的改变会使的组件之间的模块儿化变得异常的灵活，这样的写法你是否很期待呢？

12. Teleport翻译过来就是瞬移的意思，于是，国内翻译过来就是瞬移组件的，怎么来理解这个瞬移组件呢。

    我们都知道的一点是，不论是vue或者是react在入口文件的html地方，都只有一个容器就是<div id='app'></div>，我们称之为入口，同时页面上的所有组件实际都是挂载在这个节点的，打开网页，我们可以看到控制到上，最外层只有有个节点就是这个app。
    写过弹窗组件或者消息提示组件的朋友们都知道，像这种全局只有一个状态的组件，我们不希望他混入我们的组件中，我们希望他独立于app组件，所以，在大多数优秀的ui框架中，这一类的高级组件，一般会去采用新创建一个节点的方式，抽离出app节点，这样更为容易控制，并且在使用完毕后即使的删除。那么Teleoirt组件实际上就是这样的一个东西，可以独立于app之外的新的节点，我们都知道入口文件index.html都有一个节点叫app，我们新增一个app2，如图。

    然后我们怎么使用这个节点呢，我们先去创建一个简易的弹窗组件，这个组件也很简单，在页面中心展示出来就好，我们来看看这个组件和vue2有何区别吧：

    我们可以看到，这个组件外部包裹了一层Teleport标签，并且拥有一个to属性，那么首先，要使用瞬移组件就需要，这个标签包裹，那么to属性呢就代表我要挂载在哪个节点，如上图，我们创建了一个app2的节点，我们想要挂载在这个节点上面，我们to='app2'就可了，这样就创建了一个瞬移组件，使用方法和vue2没有任何区别，我们来看看实际效果吧：

    ok，就是这么简单，就完成了一个瞬移组件的创建，这样的组件在对于一些状态单一的组件创建中，变得更加丝滑了，不会对使用的组件内部造成任何破坏，也不会出现样式污染等各类问题，非常的实用。

13. Vue3的异步请求组件Suspense
    这个异步组件(Suspense)呢是vue3新加的一种组件，再日常的开发中，异步组件是不可缺少的一部分，例如接口请求，图片请求，各种异步操作所导致的请求都属于异步组件，在vue2中这些状态的判断都需要我们自己手动去判断，但是vue3提供这一非常贴心的组件，这个中文翻译过来就是悬念的意思，他提供了两个template 也就是两个插槽，一个是没请求回来的时候显示什么，一个是请求成功显示什么，我们来写一个看看吧，先来写个异步的组件，非常简单，这里的这个接口是一个随机返回一张图片的接口。

    这里呢就是随机返回一个图片，我们来引入这个组件使用吧：

    使用非常简单，通过Suspense标签包裹的组件就是异步组件，在其中，提供了两个插槽，分别是成功和失败的插槽，会对应显示其中的内容，这样的写法可以方便我们少做很多冗余的判断，是不是也很好用呢





