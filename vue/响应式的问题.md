# 为什么需要依赖收集

```
如果一个值没有在实际模版渲染中用到，但是更改它的值 还会触发模版渲染，显然是不正确的
```
# vue2 和 vue3 响应式不变的内核东西

Object.defineProperty -> Proxy
Dep.target -> activeEffect 保留当前触发的watcher然后watcher收集依赖
targetStack -> effectStack 保留当前的effect Stack 避免外层函数收集不到和内层函数相同的依赖
watcher -> effect
dirty -> 在set的时候变成true 重新计算值
lazy -> computed只有值变化的时候才重新计算值，以及watch的oldValue的计算
watch的oldValue是没计算的值，newValue是通过手动调用get获取新的值
watch 的 deep 深度监听， 要避免循环引用的问题是通过set来判断是否存在循环引用，如果有循环引用就直接返回此对象
一个队列更新watch是不变的，通过flushingQueue放到一个微任务队列更新

vue3有一个很巧妙的实现是effect的schedule属性,通过这个属性，实现队列更新effect和computed的dirty属性的变化。
# 总结Vue2依赖收集

```
vue的双向数据绑定分为两个阶段

一个是数据劫持阶段

在new Vue的初始化数据时，如果是对象，直接调用Object.defineProperty修改对象中每个属性的get和set方法。
如果是数组，会改写数组的方法，在数组方法上添加更新watcher的函数，这样可以在调用数组方法时更新响应数据。同时也会修改数组中每个对象的get和set方法

一个依赖收集阶段

初次new render watcher、computed watcher和 watch watcher的时候会在watcher的构造方法中调用watcher的get方法，wacther的get方法会将全局变量Dep.target设置成此时的watcher，（全局会有一个target数组存放当前收集的依赖属于哪个watcher）在watcher用到的数据此前已经被改写自己本身的get方法，访问数据值的时候，使用Object.definProperty修改对象的get方法判断此刻有Dep.target,那么就会在调用的时候收集数据(dep)对应的watcher依赖，Dep收集watcher是为了在data变化的时候通知watcher更新，设置Dep.target再收集依赖可以避免收集到无用的data数据(也就是data变化了才更新watcher，没用到的data没有被收集变化不会通知watcher更新),同时watcher也会维护属于自己的dep，以便于在set方法调用的时候通知watcher调用自身的update方法更新使用到自己的dep的值时对比新旧依赖减少下一次dep中不需要维护的watcher订阅者(cleanupDeps)(在dep中将wacther删除，每个wacther内都有depsId和newDepsId会更新一下)，在watcher的update方法调用的时候，为了性能优化，会默认将将要更新的watcher放到queuewacther队列中，而不是马上更新。如果此刻flushing是true表示此刻正在更新中，会将相同id的watcher替换，不会因为不断加入新watcher触发多次watcher的更新。同时将watcher添加到队列中的操作会判断是否是相同的watcher id，相同的watcher只会被添加一次。不会被重复添加。如果deep是true需要深度收集依赖时，会设置一个set防止循环引用重复收集依赖。每个对象下都会有__ob__属性存放属于这个对象的dep依赖。

初次new render watcher、computed watcher和 watch watcher的时候会在watcher的构造方法中调用watcher的get方法，wacther的get方法会将全局变量Dep.target设置成此时的watcher，在data被调用set方法改写值的时候会调用watcher的update方法，update方法会调用get方法重新计算watcher的值，在watcher用到的数据此前已经被改写自己本身的get方法，访问数据值的时候，使用Object.definProperty修改对象的get方法判断此刻有Dep.target,那么就会在调用的时候收集数据(dep)对应的watcher依赖，Dep收集watcher是为了在data变化的时候通知watcher更新，设置Dep.target再收集依赖可以避免收集到无用的data数据(也就是data变化了才更新watcher，没用到的data没有被收集变化不会通知watcher更新),同时watcher也会维护属于自己的dep，以便于在set方法调用的时候通知watcher调用自身的update方法更新使用到自己的dep的值时对比新旧依赖减少下一次dep中不需要维护的watcher订阅者(cleanupDeps)(在dep中将wacther删除，每个wacther内都有depsId和newDepsId会更新一下)，在watcher的update方法调用的时候，为了性能优化，会默认将将要更新的watcher放到queuewacther队列中，而不是马上更新。如果此刻flushing是true表示此刻正在更新中，不会因为不断加入新watcher触发多次watcher的更新。同时将watcher添加到队列中的操作会判断是否是相同的watcher id，相同的watcher只会被添加一次。不会被重复添加。


dep 收集 watcher 和 watcher 收集 dep 都是在 Object.defineProperty 的get中，但是每次watcher的update执行完都要cleanupDeps是因为，更新之前once是true，已经执行过一次渲染更新了之后，比如<div v-if="{{once}}">{{onceData}}</div>,如果once变成false那么onceData的更新不必通知render watcher执行，所以需要cleanupDeps
```


# 总结Vue3依赖收集


Vue双向数据绑定的两个阶段

1.数据劫持阶段 --- 创建proxy对象

在调用reactive方法创建响应式数据的时候创建响应式对象，创建Proxy对象，在get对象内部会使用Reflect.get返回对象，因为避免继承对象访问属性时this被修改的问题，如果get访问的结果是对象的话会返回一个reactive的对象如果有继续访问这个reactive对象的属性的操作的话，就会继续掉进get陷阱中。执行track函数，

在proxy对象内部定义set方法，在更新值的时候会通过Proxy的set方法触发依赖更新。同理get操作同样使用Reflect实现。对于继承对象访问本身的属性值并且新旧值有变化才会执行trigger方法，避免触发两次依赖更新和effect的执行。对于数组的更新判断是set还是add操作，如果是数组的add会触发length相关的effect执行。如果是对象的add会触发for...in操作的effect的执行。

has建立对于使用in操作符的effect的收集
ownKeys建立对for..in操作符的effect的收集
deleteProperty建立对delete 属性值操作符的收集

2.依赖收集阶段

执行track函数中会将effect函数收集到对象的key属性中，建立depsMap和depsSet，set收集的是一个属性的不同effect，depsMap是一个组件中不同对象的依赖 只有key变化才会执行effect，这样比vue2的收集依赖收集到对象下遍历每个key值有优化作用。性能更好。

执行trigger函数，对于不是readonly和不是symbol类型的属性直接执行trigger收集依赖，对于数组有单独的处理需要判断是set还是add因为add会涉及到对数组长度的effect的执行。添加到新建的effectToRun set中执行。为什么要新建一个effectToRun而不是直接执行effects，是因为不断执行effect就会重新收集依赖，然后将依赖effect添加到effects中不断执行。循环执行。如果是ADD和DELETE操作的话需要考虑涉及到访问iterate属性的effect的执行也要在本次effectToRun set中，如果是数组并且修改了length属性那么访问了length的effect也要执行，如果直接修改了数组的length属性那么相关effect也要执行。

每个effect执行的过程前都会清空上一次的依赖，因为避免某个值变成false导致view的值被重新收集依赖，避免不必要的渲染。
创建一个全局的activeEffect保存此刻的副作用函数，并且建立effectStack数组以防嵌套effect，如果没有effectStack数组，那么某个响应式数据一开始在内层有个属性被访问，那么此时activeEffect是内层函数。如果这个响应式数据在外层副作用函数中被读取了一个属性，他们收集的副作用函数永远是内层副作用函数不会更改。但是此时这个属性的activeEffect应该是外层函数才对。

vue是异步批量更新的这得益于effect支持传一个scheduler实现。effect执行的时候会判断如果有scheduler那么就按照scheduler的规则执行否则就直接执行effect函数。在scheduler中会判断如果同步任务都执行完会执行promise微任务。此时任务队列中已经添加好了一系列要更新的effect，然后统一执行。

computed 的 缓存执行也是依靠schduler执行dirty是false才会执行，每当依赖变化dirty才会重新变成true否则就是false，因为effect执行会执行effect.scheduler将dirty变成false

watch 的 immediate也是在scheduler内执行，如果是immediate就立马执行如果是watch在同步任务执行完之后再执行就放到promise.then中执行




