# 为什么需要依赖收集

```
如果一个值没有在实际模版渲染中用到，但是更改它的值 还会触发模版渲染，显然是不正确的
```

# 总结Vue2依赖收集

```
vue的双向数据绑定分为两个阶段

一个是数据劫持阶段

在new Vue的初始化数据时，如果是对象，直接调用Object.defineProperty修改对象中每个属性的get和set方法。
如果是数组，会改写数组的方法，在数组方法上添加更新watcher的函数，这样可以在调用数组方法时更新响应数据。同时也会修改数组中每个对象的get和set方法

一个依赖收集阶段

初次new render watcher、computed watcher和 watch watcher的时候会在watcher的构造方法中调用watcher的get方法，wacther的get方法会将全局变量Dep.target设置成此时的watcher，在watcher的get方法中访问数据值的时候，之前使用Object.definProperty修改对象的get方法判断此刻有Dep.target,那么就会在调用的时候收集dep对应的watcher依赖，设置Dep.target再收集依赖可以避免未用的数据变化导致无用的更新,同时watcher也会维护属于自己的dep，以便于在set方法调用的时候通知watcher调用自身的update方法更新数据时对比新旧依赖减少下一次dep中不需要维护的watcher订阅者，在watcher的update方法调用的时候，为了性能优化，会默认将将要更新的watcher放到queuewacther队列中，而不是马上更新。如果此刻flushing是true表示此刻正在更新中，不会因为不断加入新watcher触发多次watcher的更新。
```


# 总结Vue3依赖收集


```
Vue双向数据绑定的两个阶段

1.数据劫持阶段

在调用reactive方法创建响应式数据的时候创建响应式对象，
get方法会收集依赖，set方法会触发订阅者的更新

2.依赖收集阶段

在首次mount组件的时候创建一个effectScope，将组件的render函数放到effectScope函数中执行，此时render函数中调用的响应式数据会进入响应式对象的get陷阱中，此时会收集此刻effectScope内的响应式依赖，并且在创建effectScope的时候还会传进一个处理队列的函数，函数会将多个effectScope放到队列中更新。当触发响应式数据的set方法的时候，会调用sheduler函数处理多个effectScope的更新。effectScope的stop方法停止更新也会将dep依赖中的effectScope订阅者清除掉， 无需更新这个effectScope的值即可
```
