# 性能优化
## 性能优化指标的计算
[老板让你做性能优化，第一步你应该做什么](https://juejin.cn/post/7121323745980973070)
[有道优化页面性能的手段](https://juejin.cn/post/7064405926035324964#heading-1)
[react官网的渲染优化](https://juejin.cn/post/7128369638794231839)
[React项目的性能优化](https://mp.weixin.qq.com/s/XSvhOF_N0VbuOKStwi0IYw)
* 在 HTML 内实现 Loading 态或者骨架屏；
* 去掉外联 css；
* 缓存基础框架；
* 使用动态 polyfill；
* 使用 SplitChunksPlugin 拆分公共代码；
* 正确地使用 Webpack 4.0 的 Tree Shaking；
* 使用动态 import，切分页面代码，减小首屏 JS 体积；
* 编译到 ES2015+，提高代码运行效率，减小体积；

使用 lazyload 和 placeholder 提升加载体验。
### 性能是相对的情况
1.设备不同：网速的问题
2.实现方式不同：加载速度一样，一个内容显示的比另一个快很多。，原因一个按需加载，另一个要等所有内容加载完了才显示
3.使用技术不同：两个图形化编辑网站，卡顿的是用dom实现的，一个是用canvas或者webGL实现的就更加流畅

### 规范指标
[原文链接](https://juejin.cn/post/6962742206692065287)
- **FCP（First Contentful Paint）首次内容绘制**
```
指浏览器从响应用户输入网络地址到页面内容的任何部分在屏幕上完成渲染的时间。这个就是实际有意义的首屏时间
if (window.performance) {
    let pf = window.performance;
    let pfEntries = pf.getEntriesByType('paint')
    let fp = pfEntries.find(each => each.name === 'first-contentful-paint')
    console.log('first paint time: ', fp && fp.startTime)
}
```
- **FP白屏时间(首次渲染时间)**
```
if (window.performance) {
    let pf = window.performance;
    let pfEntries = pf.getEntriesByType('paint')
    let fp = pfEntries.find(each => each.name === 'first-paint')
    console.log('first paint time: ', fp && fp.startTime)
}
```
- **LCP（Largest Contentful Paint）最大内容绘制**
表示可视区最大内容（文本块或图像元素）在屏幕上完成渲染的时间。该时间会随着页面渲染变化而变化，因为页面中的最大元素在渲染过程中可能会发生改变，另外该指标会在用户第一次交互后停止记录
```
const observer = new PerformanceObserver((list) => {
  let perfEntries = list.getEntries();
  let lastEntry = perfEntries[perfEntries.length - 1];
  // Process the latest candidate for largest contentful paint
});
observer.observe({entryTypes: ['largest-contentful-paint']});
if (window.performance) {
    let pf = window.performance;
    let pfEntries = pf.getEntriesByType('paint')
    let fp = pfEntries.find(each => each.name === 'largest-contentful-paint')
    console.log('first paint time: ', fp && fp.startTime)
}
```
- **TTI（Time to Interactive）可交互时间**
测量页面从开始加载到视觉上完成渲染、初始脚本完成加载，并能够快速、可靠地响应用户输入所需的可交互状态时间。 可交互状态指的是页面上的 UI 组件是可以交互的（可以响应按钮的点击或在文本框输入文字等）。
- **TBT（Total Blocking Time）总阻塞时间**
指 FCP(首次内容绘制) 与 TTI (可交互时间)之间的总时间。这期间，主线程被阻塞的时间过长，无法作出输入响应。任务的持续时间超过50毫秒。虽然在主线程上运行任务的总时间为 560 毫秒，但其中只有 345 毫秒被视为阻塞时间
- **CLS (Cumulative Layout Shift) 累积布局偏移**
累积布局偏移 (CLS) 是一个以用户为中心的测量视觉稳定性的重要指标，因为该项指标有助于量化用户发生意外布局偏移的频率，较低的 CLS 有助于用户的使用体验。解释一下就是想点取消，但因为别内容加载出来把按钮顶下去了，所以点成了确定订单。大写的尴尬。以前 CLS 测量的是整个页面生命周期内发生的所有单次布局偏移分数的总和。现在 CLS 测量的是整个页面生命周期内发生的所有意外布局偏移中最大一连串的布局偏移分数。布局偏移：每当一个可见元素的位置从一个已渲染帧变更到下一个已渲染帧时，就发生了布局偏移。一连串的布局偏移：也叫会话窗口，是指一个或多个快速连续发生的单次布局偏移，每次偏移相隔的时间少于 1 秒，且整个窗口的最大持续时长为 5 秒。
最大的一连串：是指窗口内所有布局偏移累计分数最大的会话窗口。
- **FID（First input delay）首次输入延迟**
测量从用户第一次与您的网站交互（例如当他们单击链接、点按按钮或使用由JavaScript驱动的自定义控件）直到浏览器实际能够对交互做出响应所经过的时间。页面的 FID 应为100 毫秒或更短。
- **FPS 屏幕的刷新率为 60fps**
当页面元素动画、滚动或者渐变时绘制速率小于 60，就会不流畅，小于 24 就会卡顿，小于 12 基本认定卡爆了。1 帧的时长约 16ms，除去系统上下文切换开销，每一帧中只留给我们 10ms 左右的程序处理时间，如果一段脚本的处理时间超过 10ms，那么这一帧就可以被认定为丢失，如果处理时间超过 26ms，可以认定连续两帧丢失，依次类推。我们不能容忍页面中多次出现连续丢失五六帧的情况，也就是说必须想办法分拆执行时间超过 80ms 的代码程序，这个工作并不轻松。页面在刚开始载入的时候，需要初始化很多程序，也可能有大量耗时的 DOM 操作，所以前 1s 的必要操作会导致帧率很低，我们可以忽略。当然，这是对 PC 而言，Mobile 内容少，无论是 DOM 还是 JS 脚本量都远小于 PC，1s 可能就有点长了。
- **获取加载最慢的资源时间**
```
PerformanceObserver api监听资源的加载耗时，它返回的数据里面包含了几个重要的信息
name：资源URL；
initiatorType：资源类型，取值可能是css|img|xmlhttprequest等；
startTime：请求开始时间，高精度时间戳值，单位毫秒；
responseEnd：请求响应返回的时间，高精度时间戳值，单位毫秒；
duration：responseEnd于startTime的差值；

const pfObserver = new PerformanceObserver((list) => {
    const entries = list.getEntriesByType('resource');
    entries.forEach((item) => {
        // 各种资源的耗时
        // 首屏图片资源白名单：imgUrlWhiteList = []
        console.log(`${item.name: ${item.duration}}`);
    });
});
// 设定性能监听类别：资源
pfObserver.observe({ entryTypes: ['resource'] });
```
- **如何获取加载的图片资源**
对于img标签的图片资源，我们可以在MutationObserver或者IntersectionObserver监听器中直接操作dom读取img的src或者data-src属性，把图片URL保存起来；
针对背景图片，我们使用getComputedStyle方法获取节点的样式表，并取出其background-image的值；
- **First Meaningful Paint(FMP)**
FMP定义的是从页面开始加载到渲染出主要内容的过程，这个“主要内容”的定义依赖于各浏览器中的实现细节，因此它并没有作为一个标准化的指标。

- **首屏时间**
可以通过insertObserver实现异步监听dom和屏幕的相交值，如果满足就是首屏出现的时间。
1.如果首屏内容还在加载中，用户触发了页面滚动？
页面滚动之后，第二屏的内容就会出现在视窗，原本属于首屏的内容（部分内容可能并未完成渲染）却没在视窗中。那么，按照如上的统计方式，就会统计到当前处于视窗内容的渲染时间，这可能就是一个“误差”。我们需要一个共识：在首屏内容完全渲染之前页面触发了滚动，说明页面已经是一个可交互的状态，这种情况下，我们认为，用户触发滚动时那一帧的内容，已经是用户和开发者双方都能接受的首屏内容。基于这个前提，我们的处理方式是：
在页面滚动时，加一个锁，停止监听后续内容的变更，以初次滚动的时间点为时间界线，统计在此时间点前发出的（依据startTime）所有资源的请求耗时和dom树节点的渲染时间。

2.首屏内容是动态fetch的，甚至fetch的是图片资源。这种情况下只能保底统计到fetch请求的响应结束时间；
如果用户在响应之前触发了滚动，这时候数据渲染尚未开始，我们的程序无法捕捉到dom节点，那么也拿不到响应的图片资源，也就无法统计后续的渲染时间；如果用户是在数据返回之后，图片资源渲染之前触发的滚动，这种情况下由于能够捕捉dom树节点的渲染，理论上我们也能够获取响应图片资源的加载耗时；

### 每个指标的侧重点
- LCP 测量感知加载速度，并在页面的主要内容基本加载完成时，在页面加载时间轴中标记出相应的点；
- FID 测量响应度，并将用户首次尝试与页面交互的体验进行了量化；
- CLS 测量视觉稳定性，并对可见页面内容的意外布局偏移量进行了量化。

### 自定义性能指标
- 用户计时 API ：该规范定义了一个接口，以帮助 Web 开发人员通过访问高精度时间戳来衡量其应用程序的性能。
- 长任务 API ：该档定义了一个 API，网页作者可以使用该 API 来检测“长任务”的存在，这些任务会长时间垄断 UI 线程并阻止其他关键任务的执行
- 元素计时 API：本文档定义了一个 API，可以在屏幕上显示大型或开发人员指定的图像元素和文本节点时进行监控。
- 导航计时API：该规范定义了Web应用程序的接口，以访问用于导航文档的完整计时信息。
- 资源计时 API：该规范定义了Web应用程序的接口，以访问文档中资源的完整计时信息。
- 服务器计时：该规范使服务器能够将有关请求响应周期的性能指标传达给用户代理。它还标准化了JavaScript接口，以使应用程序能够收集和处理并对这些指标采取行动以优化应用程序交付。

### DOMContentLoaded
当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。意思是HTML下载、解析完毕之后就触发。就算是async和defer的脚本也是在此之前执行
### load
页面的html、css、js、图片等资源都已经加载完之后才会触发 load 事件。

## 网络层面

### DNS优化
1.在dns上做缓存减少dns查询时间

2.DNS 预解析加载 --- HTTP页面自动解析
在页面加载的过程当中，浏览器会自动将超链接 href 属性中的域名解析为 IP 地址
注意：为了确保安全性，HTTPS 页面中不允许自动解析

通过HTML标签方式
<meta http-equiv="x-dns-prefetch-control" content="on">
通过设置响应头的方式
ctx.set('X-DNS-Prefetch-Control', 'on')
说明：on 表示开启，off 表示关闭

3.手动解析（推荐）
<link rel="dns-prefetch" href="//file.cdn.com">
开启指定域名的预解析功能，多用于优化 CDN 资源，推荐在项目中使用。最佳使用位置如下
<meta charset="utf-8">
<link rel="dns-prefetch" href="//file.cdn.com">

4.域名收敛
就是将静态资源放在一个域名下。减少DNS解析的开销。

5.域名发散
是将静态资源放在多个子域名下，就可以多线程下载，提高并行度，使客户端加载静态资源更加迅速。

6.多域名解析
一个域名对应多个IP，每次域名解析请求都会根据对应的负载均衡算法计算出一个不同的IP地址并返回，这样A记录中配置多个服务器就可以构成一个集群，并可以实现负载均衡。将负载均衡的工作交给DNS，省去了网站管理维护负载均衡服务器的麻烦。

7.TTL缓存时间和异步请求。
每个DNS域名和IP在本地DNS服务器上都有TTL缓存时间。可以延长TTL缓存时间。

#### 科普DNS解析过程
为什么需要DNS解析域名为IP地址？

网络通讯大部分是基于TCP/IP的，而TCP/IP是基于IP地址的，所以计算机在网络上进行通讯时只能识别如“202.96.134.133”之类的IP地址，而不能认识域名。DNS是应用层协议，事实上他是为其他应用层协议工作的，包括不限于HTTP和SMTP以及FTP，用于将用户提供的主机名解析为ip地址。
```
1.浏览器会检查缓存中有没有域名对应的ip地址，这个缓存是有过期时长的，一般是几分钟到几小时不等。
2.如果浏览器缓存没有，那么就检查操作系统的hosts文件
3.如果本地也没有配置那么就会根据向本机配置的本地区DNS域名服务器（LDNS）发起请求，如果你是通过学校连接互联网的一般是你学校的DNS服务器，如果你是在小区连接互联网的一般是网络提供商比如电信，联通的DNS服务器，DNS服务器通常不会太远。如何查看本机的域名服务器，在Linux可以通过 cat /etc/resolv.conf查看。到这一步基本能解析80%的域名
4.如果LDNS也不能解析，那么就直接到根域名服务器请求解析。如果未用转发模式，本地DNS就把请求发至13台根DNS。
5.根域名服务器会给本地域名服务器LDNS一个所查询的主域名服务器（gTLD）地址，gTLD是国际顶级域名服务器，比如.com,.cn,.org等。根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(http://qq.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找http://qq.com域服务器，重复上面的动作，进行查询，直至找到www  . qq  .com主机。如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。

6.本地域名服务器LDNS再向上一步返回的gLTD服务器发送请求。

7.gLTD服务器查询并返回域名对应的Name Server域名服务器的地址，通常是你注册的域名服务器，例如你在某个域名服务器提供商申请的域名，那么这个域名解析任务就由这个域名服务提供商来完成。

8.Name Server域名服务器会查询存储的域名和ip的映射关系表，将ip连同一个TTL值返回给DNS Server域名服务器。

9.LDNS拿到ip和TTL会缓存起来，缓存时间由TTL值控制。

10.把解析的结果返回给用户，用户根据TTL值缓存在本地系统缓存中，域名解析过程结束。入Name Server也有可能有多级或者一个GTM来控制负载均衡，都能影响DNS解析过程。
```
[dns查询流程图](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cfc3072677f44c88ba2f098f8dd5dc5b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

递归查询 主机向本地域名服务器的查询

迭代查询 本地域名服务器向根域名服务器的查询

#### 什么是DNS劫持

DNS劫持即通过某种技术手段，篡改正确域名和IP地址的映射关系，使得域名映射到了错误的IP地址，因此可以认为DNS劫持是一种DNS重定向攻击。DNS劫持通常可被用作域名欺诈，如在用户访问网页时显示额外的信息来赚取收入等；也可被用作网络钓鱼，如显示用户访问的虚假网站版本并非法窃取用户的个人信息。

【一、本地DNS劫持】
客户端侧发生的DNS劫持统称为本地DNS劫持。本地DNS劫持可能是：

黑客通过木马病毒或者恶意程序入侵PC，篡改DNS配置(hosts文件，DNS服务器地址，DNS缓存等)。
黑客利用路由器漏洞或者破击路由器管理账号入侵路由器并且篡改DNS配置。
一些企业代理设备（如Cisco Umbrella intelligent proxy）针对企业内部场景对一些特定的域名做DNS劫持解析为指定的结果。

【二、DNS解析路径劫持】DNS请求转发 DNS请求复制

#### DNS解析是基于UDP的，因为不需要建立链接浪费时间，时效性比较好

TCP通信过程太复杂并且开销大，一次TCP交换需要9个包： 三个连接包，四个断开包，一个request包，一个响应包。

UDP通信过程简单，只需要一个查询包和一个响应包。

#### 权威服务器
COM顶级服务器可以授权xxorg.com这个域名的的权威服务器为NS.ABC.COM

#### 递归DNS
递归DNS又称为Local DNS，它没有域名解析结果的决定权，但代理了用户向权威DNS获取域名解析结果的过程。递归DNS上有缓存模块，当目标域名存在缓存解析结果并且TTL未过期时（每个域名都有TTL时间，即有效生存时间，若域名解析结果缓存的时间超过TTL，需要重新向权威DNS获取解析结果），递归DNS会返回缓存结果，否则，递归DNS会一级一级地查询各个层级域名的权威DNS直至获取最终完整域名的解析结果。eg: 我们自己的电脑，运营商提供的dns服务器等等。

#### 公共DNS
公共DNS是递归DNS的一种特例，它是一种全网开放的递归DNS服务，而传统的递归DNS信息一般由运营商分发给用户。

#### 转发DNS
可以理解为递归DNS和用户之间的一个中转站，它不提供直接解析域名的服务，它将请求转发给递归DNS，然后将递归DNS的结果转发一下，也提供缓存作用。比如，日常家用的路由器，它的DNS服务器一般都是192.168.1.1，只是转发给递归DNS。

#### HTTPDNS
HTTPDNS使用HTTP与DNS服务器交互，代替传统的基于UDP的DNS协议，域名解析请求直接发送到HTTPDNS服务端，从而绕过运营商的Local DNS

HTTPDNS优点
```
1.防止域名劫持
由于 HttpDns 是通过 IP 直接请求 HTTP 获取服务器 A 记录地址，不存在向本地运营商询问 domain 解析过程，所以从根本避免了劫持问题。
2.精准调度
HTTPDNS能够直接获取到用户的IP地址，从而实现精确定位与导流
3.用户连接失败率下降
通过算法降低以往失败率过高的服务器排序，通过时间近期访问过的数据提高服务器排序，通过历史访问成功记录提高服务器排序。
```
### 将静态资源放在CDN服务器上
什么是CDN CDN是如何做到快速返回数据的

CDN的全称是Content Delivery Network，即内容分发网络。其目的是通过在现有的Internet中增加一层新的CACHE(缓存)层，将网站的内容发布到最接近用户的网络”边缘“的节点，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。从技术上全面解决由于网络带宽小、用户访问量大、网点分布不均等原因，提高用户访问网站的响应速度。

### 建连复用：SSL化，SPDY建连高复用

SSL化，SSL化之后每个域名首次请求会额外增加一个“SSL握手”的时间，DNS建连也会比http的状态下要长，这是不可避免的，但是为什么一次完整的RequestRespone 流程耗时会比http状态下短呢？合理的解释是：SSL化之后，SPDY可以默认开启，SPDY协议下的传输效率和建连复用效益将最大化。SPDY协议下，资源并发请求数将不再受浏览器webview的并发请求数量限制，并发100+都是可能的
### 减少http请求，合并http请求
合并的原则

### 服务器端提供html和http静态资源时最好开启gzip

### http静态资源尽量用多个子域名,减少浏览器域名并发请求限制

### http缓存资源

### prefetch preLoad 区别 作用

### http2多路复用

### 开启keep-alive
在http1.1中默认开启了了Connection:keep-alive，它的作用是在下次发送请求时在一定时间内可以复用上一次的tcp链接而不需要重新建立这个链接
## 构建层面

### 资源加载优化的原则

```
1.第一个是关键资源个数。关键资源个数越多，首次页面的加载时间就会越长。
2.第二个是关键资源大小。通常情况下，所有关键资源的内容越小，其整个资源的下载时间也就越短，那么阻塞渲染的时间也就越短。
3.第三个是请求关键资源需要多少个 RTT（Round Trip Time）。RTT 就是这里的往返时延。它是网络中一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认，总共经历的时延。通常 1 个 HTTP 的数据包在 14KB 左右，所以 1 个 0.1M 的页面就需要拆分成 8 个包来传输了，也就是说需要 8 个 RTT。

总的优化原则就是减少关键资源个数，降低关键资源大小，降低关键资源的 RTT 次数。
```
### 代码拆包打包优化

[具体的拆分包的操作过程](https://juejin.cn/post/6910893471339708429) 

1.将vendor中的第三方包尽量使用cdn链接的方式，利用externals的方式，首先将 CDN 引入的依赖加入到 externals 中。然后借助 html-webpack-plugin 将 CDN 文件打入 html。

利用webpack的splitchunks打包，将node_modules中的包打包到vendor中，但是有时候vendor会过大
其实可以使用第三方包的cdn链接，开启cdn加速，这样可以减少vendor包的大小，并且可以利用cdn加速

如果如果我们想引用一个库，但是又不想让 webpack 打包，并且又不影响我们在程序中以 import、require 或者 window/global 全局等方式进行使用，那就可以通过配置 externals

externals 配置选项提供了「从输出的 bundle 中排除依赖」的方法。相反，所创建的 bundle 依赖于那些存在于用户环境(consumer's environment)中的依赖。

减少不必要的js文件加载

关闭sourceMap
```
sourcemap是为了方便线上调试用的，因为线上代码都是压缩过的，导致调试极为不便，而有了sourcemap，就等于加了个索引字典，出了问题可以定位到源代码的位置。
但是，这个玩意是每个js都带一个sourcemap，有时sourcemap会很大，拖累了整个项目加载速度，为了节省加载时间，我们将其关闭掉。
vue.config.js配置
productionSourceMap: false, //取消.map文件产生

```
不打包库文件

```
chainWebpack: config => {
      // 在这里设置 需要cdn的依赖和插件
      config.set('externals', {
        'vue': 'Vue',
        'vue-router': 'VueRouter',
        'axios': "axios",
        'moment': "moment",
      });
      //这是一个方法,对config进行了操作之后必须要return出来
      return config
    },
```
在public/index.html的head标签中可以引入如下的cdn地址:

```
<script src="https://cdn.bootcdn.net/ajax/libs/vue/2.6.11/vue.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/axios/0.21.0/axios.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/vue-router/3.2.0/vue-router.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/moment.js/2.29.1/moment.min.js"></script>
```
2.拆vendor如果第三方包没有提供cdn链接，那么就分开拆成多个包在不同页面引入即可。将首页需要的包和其他页面需要的包拆分打包。
[配置打包例子图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42584ebdea5b4a4faa4ea3e1b9c29a01~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

3.动态引入

```
比如有些包是用户点击操作之后才需要加载的，例如路由跳转，可以改成动
```
态引入的方式import 打包成一个分包

4.不打包某些第三方包的部分文件

```
// webpack plugins
plugins: [
  // Ignore all locale files of moment.js
  new webpack.IgnorePlugin(/^\.\/locale$/, /moment$/),
]
```
5.可以按需加载的第三方包 按需加载

### React.lazy 和 suspense 结合 懒加载组件

```
const MonacoEditor = React.lazy(() => import('react-monaco-editor'));

<suspense fallback={<div>loading....</div>}>
    <MonacoEditor/>
</suspense>
```
### vue的路由懒加载

1.对于首屏的资源，将首要渲染资源和不是首要渲染资源。使用webpack的三种分包策略分开打包实现资源按需加载。比如路由懒加载，按照如下写法(vue利用webpack的动态引入模块的方法将不同的路由页面打包成不同的chunk实现按需加载)。但实际上我们会发现加载首页代码的之后没有点击跳转路由也会加载单独打包出来的几个页面代码是因为，vue还利用了webpack的preload和prefetch

prefetch: 一种 resource hint，用来告诉浏览器在页面加载完成后，利用空闲时间提前获取用户未来可能会访问的内容。
preload：用来指定页面加载后很快会被用到的资源，所以在页面加载的过程中，我们希望在浏览器开始主体渲染之前尽早 preload

(webpack4.6.0以上支持prefetching 特性)

路由页面的代码属于prefetch资源，这些文件的加载不会影响到当前页面的打开，可以降低页面跳转的等待时间。

那可以关闭/禁用prefetch吗?」 答案是「可以」 
Prefetch 将会消耗带宽/流量。如果你的应用很大且有很多 async chunk，而用户主要使用的是对流量较敏感的移动端，那么你可能需要关掉 prefetch 并手动选择要提前获取的代码区块.

```
// vue.config.js
module.exports = {
  chainWebpack: config => {
    // 移除 prefetch 插件
    config.plugins.delete('prefetch')
    // 或者,  修改它的选项：
    config.plugin('prefetch').tap(options => {
      options[0].fileBlacklist = options[0].fileBlacklist || []
      options[0].fileBlacklist.push(/myasyncRoute(.)+?\.js$/)
      return options
    })
  }
}
```
那怎么手动选择要预读取的文件呢?

```
import(/* webpackPrefetch: true */ './someAsyncComponent.vue')
```

```
  {
    path: '/manageGroup/add',
    name: 'ManageAddGroup',
    component: () => import(/* webpackChunkName: "manageGroupAdd" */ '/views/Personal/ZGMP/AddGroup/index.vue'),
  },
  {
    path: '/privateChat/list',
    name: 'PrivateChat',
    component: () => import(/* webpackChunkName: "privateChat" */ '/views/Personal/PrivateChat/index.vue'),
  },
  {
    path: '/privateChat/add',
    name: 'PrivateChat',
    component: () => import(/* webpackChunkName: "privateChat" */ '/views/Personal/PrivateChat/add.vue'),
  },
```

### 压缩js代码
```
npm i --save-dev compression-webpack-plugin

vue.config.js配置插件
const CompressionWebpackPlugin = require('compression-webpack-plugin');
const productionGzipExtensions = ['js', 'css'];
module.exports = {
  configureWebpack: {
        plugins: [
          new CompressionWebpackPlugin({
            algorithm: 'gzip',
            test: new RegExp('\\.(' + productionGzipExtensions.join('|') + ')$'),
            threshold: 10240,
            minRatio: 0.8
          }), 
        ],
    },
}
```
## 服务端层面

1.服务端渲染SSR

TODO 同构等问题 待补充。。。

2.服务端开启gzip压缩


## 浏览器渲染层面

页面缓存(例如 vue 的 keep-alive)

模块资源缓存(缓存页面核心模块数据)

模块按需加载(拆分打包，分别请求)

数据请求优化(核心数据和营销不重要数据分开请求)

监控检测(收敛图片、资源加载失败的问题)


### 页面构建流程
[原文链接](https://juejin.cn/post/7017807404645482504)
1.js外联文件放到body底部，css外联文件放到head内

- js执行浏览器会被js引擎"霸占"，从而导致渲染进程无法执行阻塞DomTree的渲染的
- css加载并不会阻塞Dom Tree的构建
- css加载会阻塞Dom Tree的渲染，也就是Render Tree的生成
- 位于css代码之前的js代码加载执行是毫无疑问的，但位于css加载之后的代码，css代码的加载是会阻塞后续js代码的执行的。
- HTML和Css的加载其实他们是并行加载，这也就印证了我们上边提到的css加载并不会影响Dom Tree的构建。
- 同时浏览器的渲染引擎和js的解释引擎他们是互斥的，也就是说css加载和dom加载都会和js执行加载互斥的。(当然排除scirpt标签上的defer和async)属性。
- 关于第二点，css的加载并不会阻塞Dom Tree的构建，但是如果在css文件之后存在js脚本，js是会阻塞dom tree的构建的，因为css加载阻塞了js执行，所以间接的阻塞了dom tree的构建。
- css的加载是会阻塞后续js的执行的，后续js会等待css加载完成后才会执行。
- css的加载并不会阻塞Dom Tree的构建。
- css的加载是会阻塞页面渲染的，因为页面渲染的Render Tree是需要css om和dom tree进行合并从而渲染页面的。

[渲染构建流程图](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d33869c017bd4525a25632ef61fcbee4~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

#### 因为构建流程可能产生的问题

当我们的js加载快于css加载13ms完成。当js加载完成后css还在请求download中，此时由于dom Tree已经构建完毕符合我们js的执行时机,所以此时js优先于css执行完成。当我们执行js时页面上并不存在任何样式，此时我们通过getBoundingClientRect获取的值自然是不正确的。由于defer脚本已经完成，所以在css加载过程中其实线程是空虚的，所以此时js引擎会执行加载完成的defer脚本进行执行。造成js提前与css执行完毕。

所以会存在在useEffect中获取dom元素的位置会导致位置是随机值，解决办法就是用window.onload中获取位置。

### 脚本执行顺序和放置顺序
并非所有的资源都会阻塞页面的首次绘制，比如图片、音频、视频等文件就不会阻塞页面的首次渲染；而 JavaScript、首次请求的 HTML 资源文件、CSS 文件是会阻塞首次渲染的，因为在构建 DOM 的过程中需要 HTML 和 JavaScript 文件，在构造渲染树的过程中需要用到 CSS 文件。


#### async
* async 的设置，会使 script 脚本异步加载并**在允许的情况下执行**。
* 换句话说， async的执行，并不会按着 script 在页面中的顺序来执行，而是谁先加载完谁先执行。
* async 舍弃了 script脚本之间的依赖关系。而是谁先加载完谁先执行。

#### defer
* defer 的设置，会使 script 脚本异步加载；
* 如果有多个 defer属性的script 标签存在，则会按照**顺序执行** 所有script
* defer 脚本会在**文档渲染完后，DOMContentLoaded之前**执行。

# 渲染优化

1.减少DOM的数量和嵌套层级
2.图片加载优化
3.减少重绘重排
4.减少dom操作,减少读取几何布局属性
5.class代替style，
6.resize，scroll时节流防抖
7.css3开启GPU加速
8.css优化：减少选择器
9.使用骨架屏
10.不将复杂对象放到响应式对象中，使用Object.freeze
11.使用时间分片api处理长任务(耗时超过50ms的任务)
12.不要一条一条地修改DOM的样式。还不如预先定义好css的class，然后修改DOM的className
13.把DOM离线后修改。如： 使用documentFragment 对象在内存里操作DOM
14.先把DOM给display:none(有一次reflow)，然后你想怎么改就怎么改。比如修改100次，然后再把他显示出来
15.clone一个DOM结点到内存里，然后想怎么改就怎么改，改完后，和在线的那个的交换一下

## 浏览器中的进程

- 浏览器进程
- 插件进程
- GPU进程
- 网络进程
- 渲染进程（GUI渲染线程、JS引擎线程、事件触发线程）


```
浏览器进程: 你可以理解浏览器进程为一个统一的"调度大师"去调度其他进程，比如我们在地址栏输入url时，浏览器进程首先会调用网络进程。 它可以做一些子进程管理以及一些存储的处理。


渲染进程: 这个进程对于我们来说是最重要的一个进程，每一个tab页都拥有独立的渲染进程，它的主要作用是渲染页面。


网络进程: 这个进程是控制对于一些静态资源的请求，它将资源请求完成之后会交给渲染进程进行渲染。


GPU进程: 这个进程可以调用硬件进行渲染，从而实现渲染加速。比如translate3d等css3属性会骗取调用GPU进程从而开启硬件加速。


插件进程: chrome中的插件也是一个独立的进程。

```
### 页面渲染进程

```
1.浏览器通过请求得到一个 HTML文本
2.渲染进程解析 HTML 文本，构建 DOM 树
3.浏览器解析 HTML 的同时，如果遇到内联样式或者样本样式，则下载并构建样式规则（stytle rules）。若遇到 Javascript 脚本，则会下载并执行脚本
4.DOM 树和样式规则构建完成之后，渲染进程将两者合并成渲染树（render tree）
5.渲染进程开始对渲染树进行布局，生成布局树（layout tree）
6.渲染进程对布局树进行绘制，生成绘制记录
7.渲染进程对布局树进行分层，分别栅格化每一层并得到合成帧
8.渲染进程将合成帧发送给 GPU 进程将图像绘制到页面中

```

## 图片加载优化

异步队列分批加载图片
intersectionObserver加载图片
### 图片加载失败重新加载组件
```
<common-image
          class="main-card-swiper-image"
          src="{{item.image}}"
          openImageRetry="{{index < 2}}"
          imageAnalysis="{{ {open: index < 2, tag: 'home_main_card'} }}"
        ></common-image>
```

```
<template>
  <image
    wx:if="{{src}}"
    src="{{url || src}}"
    mode="{{mode}}"
    webp="{{webp}}"
    lazy-load="{{lazyLoad}}"
    show-menu-by-longpress = "{{showMenuByLongPress}}"
    binderror="errHandler"
    bindload="loadHander"
    class="img-preload-wrap"
  />
</template>

<script>
  import { createComponent } from '@mpxjs/core'
  const Omega = getApp().Omega

  createComponent({
    data: {
      url: '',
      requestCount: 0,
      isTry: 0 // 0 不重新请求  1 重新请求
    },
    properties: {
      src: {
        type: String,
        value: ''
      },
      mode: {
        type: String,
        value: 'scaleToFill'
      },
      webp: {
        type: Boolean,
        value: false
      },
      lazyLoad: {
        type: Boolean,
        value: false
      },
      showMenuByLongPress: {
        type: Boolean,
        value: false
      },
      // 以下额外添加的一些功能
      // 是否开启图片加载率分析上报
      imageAnalysis: {
        type: Object,
        value: {
          open: false, // 是否开启图片分析，每次分析都会上报一套omega埋点，请勿批量添加
          tag: '' // 类型标识，会用于分析image的时候
        }
      },
      // 开启在图片加载失败的时候进行一次自动重试操作
      openImageRetry: {
        type: Boolean,
        value: false
      }
    },
    watch: {
      src: {
        handler(val, oldval) {
          if (val && this.imageAnalysis?.open) {
            // 图片链接请求更改，重置状态
            if (oldval) {
              this.url = ''
              this.isTry = 0
              this.requestCount = 0
            }
            this.sendOmegaLog('get')
          }
        },
        immediate: true
      }
    },
    detached() {
      (!this.requestCount && this.src) && this.sendOmegaLog('unload')
    },
    methods: {
      sendOmegaLog(type, e = {}) {
        if (this.imageAnalysis?.open) {
          const maps = {
            get: 'tech_mini_image_data_sw', // 拉取数据
            err: 'tech_mini_image_error_sw', // 图片加载失败
            load: 'tech_mini_image_load_sw', // 加载图片成功
            unload: 'tech_mini_image_unload_sw' // 未执行err和load事件时，触发
          }
          Omega.trackEvent(maps[type], {
            image_src: this.url || this.src,
            tag: this.imageAnalysis?.tag,
            err_msg: e?.detail?.errMsg,
            is_try: this.isTry
          })
        }
      },
      errHandler(e) {
        this.requestCount++
        this.sendOmegaLog('err', e)
        const triggerName = this.isTry ? 'retryError' : 'error'
        this.triggerEvent(triggerName, {
          err: e,
          is_try: this.isTry
        })

        // 请求重试
        if (this.openImageRetry) {
          this.isTry = 1
          this.openImageRetry = false
          this.url = this.src + '?timestamp=' + Date.now()
          this.sendOmegaLog('get')
        }
      },
      loadHander(event) {
        this.requestCount++
        this.triggerEvent('load', event)
        this.sendOmegaLog('load')
      }
    }

  })
</script>

<style lang="stylus" scoped>
  .img-preload-wrap
    height 100%
    width 100%
</style>

```
### webp压缩格式

[原文链接](https://juejin.cn/post/7039564188385017864)

WebP 是一种同时提供了有损压缩与无损压缩的图片文件格式。可以大大压缩图片的大小，并且图片的质量和 png、jpeg 等相同。WebP 的无损压缩比 png 格式的文件平均少了 45％ 的大小。

目前大约 95.77% 的浏览器都支持 WebP 格式的图片

判断浏览器是否支持 webp 格式的图片
支持，展示 webp 格式的图片
不支持，使用图片原始格式进行展示

第一种js方式
```
   /** 
   * 判断浏览器是否支持 webp
   */
   // 方法1: 通过尝试加载一张 webp 格式的图片来判断
   function isSupportWebp(callback) {
       const imgUrl = 'https://img.alicdn.com/imgextra/i2/O1CN01uvFm6B1XMMrTkObKV_!!6000000002909-0-tps-520-280.jpg_q75_.webp';
       const image = new Image();
       image.src = imgUrl;
       image.onload = function() {
           // 加载成功，说明支持 webp，在回调函数中
           callback(true);
       }
       image.onerror = function() {
           // 加载失败，说明不支持 webp
           callback(false);
       }
   }
   /** 
   * 选择浏览器支持的图片格式
   */
   function loadImg(imgElement, compressedImg, originalImg) {
       isSupportWebp((isSupport) => {
           imgElement.src = isSupport ? compressedImg : originalImg;
       })
   }

   // 方法2: 通过判断 HTMLCanvasElement.toDataURL() 返回的 dataURI 来判断
   function isSupportWebp() {
       const str = document.createElement('canvas').toDataURL('image/webp');
       // 如果支持则会返回传入的类型 image/webp --> data:image/webp;base64,UklGRtgCAABXRUJQVlA4WAoAAAAwAAAAKwEAlQAASUNDUBgCAAAAAAIYAAAAAAQwAABtbnRyUkdCIFhZWiAAAAAAAAAAAAAAAABhY3NwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAA9tYAAQAAAADTLQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlkZXNjAAAA8AAAAHRyWFlaAAABZAAAABRnWFlaAAABeAAAABRiWFlaAAABjAAAABRyVFJDAAABoAAAAChnVFJDAAABoAAAAChiVFJDAAABoAAAACh3dHB0AAAByAAAABRjcHJ0AAAB3AAAADxtbHVjAAAAAAAAAAEAAAAMZW5VUwAAAFgAAAAcAHMAUgBHAEIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFhZWiAAAAAAAABvogAAOPUAAAOQWFlaIAAAAAAAAGKZAAC3hQAAGNpYWVogAAAAAAAAJKAAAA+EAAC2z3BhcmEAAAAAAAQAAAACZmYAAPKnAAANWQAAE9AAAApbAAAAAAAAAABYWVogAAAAAAAA9tYAAQAAAADTLW1sdWMAAAAAAAAAAQAAAAxlblVTAAAAIAAAABwARwBvAG8AZwBsAGUAIABJAG4AYwAuACAAMgAwADEANkFMUEgSAAAAAQcQEREQkCT+/x9F9D/tf0MAVlA4IIAAAABwDQCdASosAZYAPm02mUmkIyKhICgAgA2JaW7hdrEbQAnsA99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfasAAD+/9YAAAAAAAAAAA==
       // 如果不支持则会返回默认值 image/png --> data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAACWCAYAAABkW7XSAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAADGSURBVHhe7cExAQAAAMKg9U9tCF8gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAONUAv9QAAcDhjokAAAAASUVORK5CYII
       return str.indexOf('image/webp') > -1;
   }

   /** 
   * 选择浏览器支持的图片格式
   */
   function getImg(compressedImg, originalImg) {
       const isSupport = isSupportWebp();
       return isSupport ? compressedImg : originalImg;
   }
```
第二种 html方式


```
HTML 处理：<picture> 元素

  利用浏览器会选择 <picture> 元素中最匹配的子 <source> 元素，如果没有匹配的，就选择 <img> 元素的 src 属性中的 URL 这一特点。如果浏览器支持 image/webp 类型的图片，则加载 <source> 元素中 srcset 属性指向的资源，如果不支持则跳过 <source> 元素，加载 <img> 元素。

<picture>
    <source type="image/webp" srcset="https://img.alicdn.com/imgextra/i2/O1CN01uvFm6B1XMMrTkObKV_!!6000000002909-0-tps-520-280.jpg_q75_.webp" />
    <img src="https://img.alicdn.com/imgextra/i2/O1CN01uvFm6B1XMMrTkObKV_!!6000000002909-0-tps-520-280.jpg_q75.jpg"> 
</picture>

```

## 时间分片处理耗时操作
requestIdleCallback 的定位是处理不重要且不紧急的任务。requestIdleCallback 不是每一帧结束都会执行，只有在一帧的 16.6ms 中渲染任务结束且还有剩余时间，才会执行。兼容性问题不能使用。根据react文档自己实现

思路

```
1.使用 requestAnimationFrame 获取渲染某一帧的开始时间，进而计算出当前帧到期时间点；
2.使用 performance.now() 实现微秒级高精度时间戳，用于计算当前帧剩余时间；
3.使用 MessageChannel 零延迟宏任务实现任务调度，如使用 setTimeout() 则有一个最小的时间阈值，一般是 4ms；

```
具体实现
```
// 当前帧到期时间点
let deadlineTime;
// 回调任务
let callback;
// 使用宏任务进行任务调度
const channel = new MessageChannel();
const port1 = channel.port1;
const port2 = channel.port2;
// 接收并执行宏任务
port2.onmessage = () => {
  // 判断当前帧是否还有空闲，即返回的是剩下的时间
  const timeRemaining = () => deadlineTime - performance.now();
  const _timeRemain = timeRemaining();
  // 有空闲时间 且 有回调任务
  if (_timeRemain > 0 && callback) {
    const deadline = {
      timeRemaining,
      didTimeout: _timeRemain < 0,
    };
    // 执行回调
    callback(deadline);
  }
};
window.requestIdleCallback = function (cb) {
  requestAnimationFrame((rafTime) => {
    // 结束时间点 = 开始时间点 + 一帧用时16.667ms
    deadlineTime = rafTime + 16.667;
    // 保存任务
    callback = cb;
    // 发送个宏任务
    port1.postMessage(null);
  });
};
```
# 如果页面卡顿，你觉得可能是什么原因造成的？有什么办法锁定原因并解决吗？

* 是否是网络请求太多，导致数据返回较慢，可以适当做一些缓存
* 可能是某块资源的bundle太大，可以考虑拆分一下
* 然后排查一下js代码，是不是某处有过多循环导致占用主线程时间过长
* 浏览器某帧渲染的东西太多，导致的卡顿
* 在页面渲染过程中，可能有很多重复的重排重绘
* 内存泄漏导致浏览器gc时间太长

# 实际小程序开发性能遇到的问题
1.首开时间长，首屏引入组件过多，js加载时间长，将不主要的组件放到异步分包中加载。同时整理营销公共组件到不同分包中可以减少营销组件多次打包造成包体积冗余的问题。

2.首屏运营资源位过多，改造接口将准星运营配置数据接口一次性请求所有首页资源位数据。拆分接口将关键模块接口和营销接口数据拆分成两个接口返回数据。

3.图片加载过多，雪碧图和加载图片失败重试。

4.关键模块优先，首页主要接口先请求。其他接口次之。