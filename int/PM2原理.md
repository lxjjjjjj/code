### Node的cluster
```
Node主线程是单线程的，应用程序运行于单个进程中，如果使用node index.js方式运行，就启动了一个进程，只能在一个CPU中进行运算，无法充分利用服务器的多核CPU。因此，需要多进程分发策略，即主进程接收所有请求，然后通过一定的负载均衡策略分发到不同的 Node.js 子进程中。Node的 cluster 模块，不仅提供了开箱即用的能力去使用服务器的多核CPU，而且还提供一个零停机时间重新启动整个应用程序能力，提高Node进程的可用性。

cluster 模块基于child_process模块的fork方法，多次fork主进程，产生多个子进程，这样就可以使用多核CPU，充分利用了服务器的资源。
这种方式 主进程监听一个端口，子进程不监听端口，通过主进程分发请求到子进程，支持负载均衡。PM2进程管理工具会将这个过程变得更容易执行。在 cluster 模式中存在 master 和 worker 的概念，master 就是主进程，worker 则是子进程。master会通过fork产生多个worker，并管理他们。每一个worker代表着一个应用程序的实例。
master会接收所有的请求，并通过负载均衡算法(round-robin)分发给子进程。Linux服务器默认会开启这个功能，并且可以全局修改以让操作系统本身支持负载均衡。

共享状态和负载均衡粘性分配。例如：采用集群的方式，我们不能将数据放到内存当中，因为每个worker进程都独有自己的内存空间。假如我们将数据缓存在一个woker进程中，其他woker进程无法访问到。
假如我们想要在集群模式下缓存数据，我们就需要使用想Redis这样的工具。
验证用户。对于集群，身份验证请求通过master进程发送给一个worker进程。该worker进程将开始识别该用户的状态。但是，当同一个用户发出另一个请求时，负载均衡可能会将它们发送给其他没有经过身份验证的工作人员。在一个实例内存中保留对该用户身份验证的会话将不再起作用。
这个问题可以通过多种方式解决。通过将这些会话的信息存储在共享数据库或 Redis 节点中，这样多个woker进程之间可以共享状态。但是，应用此策略需要更改一些代码，这并不是唯一的解决方法。还有另一中侵入性更小的方式—负载均衡粘性分配。因为负载均衡工具都支持此方式，实现起来也比较容易。当用户通过woker的身份验证时，我们在负载均衡器处保留这个关系的记录，形成一张映射表。当接到同一用户请求，在映射表中进行查找，找到之前的会话在哪个woker进程中，然后再次分配到该woker进程中。

```
### PM2原理

[pm2的实现原理](https://quincychen.cn/pm2-implementation/)
[pm2实现原理2](https://lagou.feishu.cn/docs/doccnyq5KSbMLfuu9y4bJVMKCKb#)

```
pm2 基于 cluster模块 进行了封装，它能自动监控进程状态、重启进程、停止不稳定进程、日志存储等。利用 pm2 时，可以在不修改代码的情况下实现负载均衡集群。

这篇文章我们要关注的是 pm2 的 Satan进程、God Deamon守护进程 以及 两者之间的 进程间远程调用RPC。其中 Satan.js 提供程序的退出、杀死等方法，God.js 负责维持进程的正常运行，God进程启动后一直运行，相当于 cluster 中的 Master进程，维持 worker 进程的正常运行。pm2 的执行流程，每次命令行输入时都会执行一次 Satan 程序，然后判断 God 进程是否正在运行，确保 God 进程正常运行后， Satan 会通过 RPC 调用 God 中对应的方法启动服务。
```
