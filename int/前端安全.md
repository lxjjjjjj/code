# 鉴权
## 敏感接口身份认证
1.接口应对调用方进行身份认证、认证采取token或签名的方式
2.建议优先使用签名的方式进行接口认证，并采用安全的签名算法。比如hmac-sha256、RSA 同时加签时加入时间戳参数，比如时间超过30s 就算token过期
3.安全级别较低的场景也可以使用token认证，但需要保证每个客户端token的一致性，不可以伪造。

## 通过token方式进行认证
token用来标识用户身份，具有唯一性、不可伪造等特征，可以是一个随机字符串或包含一定信息的有意义的字符串（如JWT），服务端需要根据token获取用户身份信息、权限信息、资源信息等的对应关系，客户端可以在请求参数或请求的http header中携带token，服务端通过token识别用户身份。

优点：比较简单

缺点：无法实现防重放、完整性校验、并且token在网络中传输存在泄漏风险

实际案例：github、gitlab

token类型：

1、随机字符串token，需要满足一定的长度、随机性、唯一性，客户端请求是携带此token，服务端根据token查询对应的身份、权限等信息来进行认证、鉴权。

优点：体积小；服务端可以主动进行失效。
缺点：服务端拿token到数据库或缓存里查询用户的信息会占用一定的资源。

2、json web token（JWT），JWT可以将用户的身份、角色、权限等信息编码后放在token里，为了防止用户恶意伪造token里的信息，token是有签名的，签名使用的key仅仅保存在服务端，客户端就无法伪造。

优点：身份、角色可以存放在客户端token里，避免了数据库的查询、适合分布式环境下无状态的要求。

缺点：体积比较大，网络传输会加大；服务端只能通过签名验证token的有效性，无法主动对其失效，只能通过加入时间戳信息等待其过期失效，一旦泄露风险较大。

token分发：

此方案需要预先将token分发给客户端，分发token的方式通常有两种：

1、通过web控制台。    

这种方式用于用户群体比较庞大的场景，可以让用户通过服务端的web控制台进行获取，通常用户登录web控制台生成token，然后使用token调用API，比如github。注：这里为了安全起见建议在第一次生成token后提示用户保存不再提供二次查询或者二次查询是进行短信验证码验证。通过线下的方式进行token分发。这种方式用于用户群体比较小的场景，服务方可以将token以邮件或短信等方式直接告诉调用方。

## 使用签名进行认证
服务端使用签名对客户端进行认证，客户端可以在请求参数中携带身份标识AcdessId及签名信息sign，服务端对签名信息进行验签进行身份认证，这种方式认证通常需要为每个用户分配一个AcdessId作为身份标识、和一个SecretKey用于对数据进行签名。为了防止重放建议再增加一个timestamp或nonce（每此调用前向服务端请求一个nonce随机数，一次失效）参数。

优点： 密钥不需要在网络中传输，可以在加签的参数中加入timestamp、nonce参数来防重放、并且能保证完整性校验

缺点：需要有一对AcdessId/SecretKey比较复杂，有效场景可以和2.1中的token方案配合使用，通过AcdessId/SecretKey获取token，再使用token进行认证鉴权，比如公有云常用的RAM+STS方案。

签名算法：

常用的签名算法有三类

1、md5、sha1、sha2（sha256、sha384、sha512）等hash算法

常见签名生成方式，以sha1举例：

sha1(消息+SecretKey)

sha1(SecretKey+消息) ，安全性较低，不推荐使用

sha1(SecretKey+消息+SecretKey)

实际案例：目前滴滴很大一部分签名方案都是这样，算法可能采用了更弱的md5，这里我们更推荐使用hmac类算法。

2、hmac（基于Hash的消息验证码）

根据hash算法的不同常用的算法有hmac-sha1、hmac-sha256等，hmac方案跟上一节的使用hash算法拼接secret进行签名的功能是一样的，不过实现方式不一样，hmac更安全。

实际案例：阿里云、AWS

3、RSA、DSA、ECDSA等数字签名算法

使用数字签名算法的好处是私钥签名、公钥验签，服务端可以不用知道调用方的私钥，安全性比较高，在一些特殊场景，比如滴滴支付，能更好的满足防抵赖的要求。

实际案例：滴滴支付、支付宝

密钥分发：

签名认证的方案需要预先将用来签名的密钥分发给调用方，分发密钥的方式通常有三种方式：

1、通过web控制台分发。    

这种方式用于用户群体比较庞大的场景，也是最广泛的方式，可以让用户通过服务端的web控制台进行获取，通常用户登录web控制台生成一对AcdessId/SecretKey。

注：这里为了安全起见建议在第一次生成token后提示用户保存不再提供二次查询或者二次查询是进行短信验证码验证。

2、用户自行生成，并将公钥上传到平台。   

对于使用非对称签名算法比如RSA的情况也可以让用户自己生成然后将自己的公钥上传给平台，这样优点是用户的私钥只有用户自己知道，服务端只有用户的公钥。

3、通过线下的方式进行AcdessId/SecretKey分发。

这种方式用于用户群体比较小的场景，服务方可以将token以邮件或短信等方式直接告诉调用方。如果调用方只有一个用户，也可以不用AcdessId。

## 使用ip白名单进行认证
这种方式用于用户群体很小的场景，服务方可以通过调用方的ip地址来判断对方的身份并决定是否允许进行调用。此方案通常和其他方案配合使用，比如和签名方案一起使用可以防止调用方在secret泄露的情况下被身份冒用的风险。

优点： 实现成本低，可以在网络或业务代码层面实现
缺点：只能针对用户量很小的场景，安全性较低，通常和其他方案配合使用
实际案例：比如公司和银行、运营商的一些接口调用。
## 方案选型
1、对于安全性要求较高的场景建议优先考虑使用签名进行认证，并选择hmac-sha256等更安全的算法。

2、对于安全性要求较高的场景同时有抗抵赖的需求，比如支付，建议选用非对称算法进行签名认证，比如RSA等。

3、如果对易用性要求较高，可以优先考虑token认证方案。

4、如果用户量很小，但对安全性的要求很高，一旦secret或token泄露被身份冒用可能产生严重后果，建议同时使用ip白名单的方案。

注意：这里的方案只是针对认证给出的，设计时还需要考虑加密+权限+审计相关的安全功能。

## 未授权访问漏洞原理和修复方案

### 原理
忘记给敏感信息接口加未登陆校验。如何防御

1. 使用网关进行访问权限管控，并定期检查
2. 默认所有接口需要访问权限，通过白名单开放无需授权接口

## 防止身份伪造
给外部用户提供服务的web系统，给合作伙伴提供信息管理的web系统。

具体要求：

服务端需统一使用ticket获取当前用户，作为身份认证的判断条件，进而进行权限校验。
不允许直接使用客户端传入的useid、roleid 用户可控且易于伪造的参数

安全加固方案

用户登陆成功之后给客户端返回ticket，后续使用ticket进行身份认证并鉴权。

ticket需要注意的点

使用复杂随机或jwt等方案，保证ticket的不可伪造性，避免使用邮箱、手机号码的hash作为ticket

ticket设置一定的过期时间，防止ticket泄漏造成的身份伪造。

常见的错误案例

不要使用useid、roleid等参数，这种方式用户可控。进而导致假冒身份。以及手机和邮箱的hash。ticket没有设置过期时间。

## 水平越权漏洞原理及修复方案
### 原理
越过系统设置的权限使用别人的权限进行操作
### 水平&垂直案例
垂直越权 ：普通用户使用了管理员权限 
* 攻击者通过更改cookie的值拥有更高的权限，
* 通过直接访问审批接口，虽然页面没有审批按钮。审批接口没有校验用户权限。
水平越权 ： 普通用户A访问了普通用户B的数据，或者使用本应该是B才能执行的操作
* 没有校验用户id 和 token 传任何id都可以获取另一个用户的信息。所以会出现越权


### 危害
泄漏用户信息、违规操作
### 防御方法
垂直越权
* 基础安全架构、完善用户权限体系。要确定哪些数据对应哪些用户，哪些数据不应该哪些用户操作。
* 鉴权 服务端对请求的数据和当前用户身份做校验
* 对于可控参数进行严格的检查和过滤
* 接入upm

水平鉴权
将资源id进行随机化uid能够减缓水平越权
严格校验数据所属用户
# 跨域
# https
# xss攻击

## 原理
攻击者在页面注入恶意的客户端代码。从而在用户浏览网页的时候执行攻击者注入的恶意代码
## 反射型XSS 
用户点击url，形如 xiaojukeji.com?value=<script>alert(/xss/)</script>发出请求后，xss代码出现在url中，作为输入提交到服务器，服务器响应内容中有这段XSS代码，之后浏览器解析执行。浏览器未转译用户的输入，直接将用户的<script>执行，攻击者拿到用户信息重新访问服务器。
## 存储型XSS 
恶意脚本直接存储在数据库、内存、文件中，浏览器未转译直接执行。比如社区写文章或者评论直接提交到数据库，不需要构造链接，攻击很稳定。

## DOM型XSS
不需要服务器的参与，通过浏览器端解析造成攻击，在浏览器解析修改DOM树。一般的攻击方法是，攻击者构造一个URL，诱发用户点击，用户点击后，url可以利用XSS漏洞获取用户信息，比如cookie。js操作了url的数据

## 危害
* 窃取用户信息，冒充用户身份进行各种操作
* 网站挂马，在用户的计算机中植入木马
* 发送广告或者垃圾信息
* 钓鱼攻击，构造一个页面跳转的恶意代码，使受害者跳到一个伪造的页面上
* 构造恶意请求，get/post
* xss蠕虫 一种具有自我传播能力的XSS
## 防范 
控制用户的输入，对输入进行检查，检查< > 白名单过滤和合格的输入检查，客户端检查可以减少服务器压力

1. html里输出进行htmlEncode编码
```
编码前
<script>alert(123)<script>
编码后
&lt;script;alert(123)&lt;/script&gt
```
2. 在script标签、事件里。在script标签可以直接执行js代码。进行javascriptEncode编码即可
```
编码前
let str = '<img src=@ onerror=alert(/xss/)/>'
escape(str)
编码后
"%3Cimg%20src......"
```
3. 在地址栏中输出 进行URLEncode编码

4. 框架输出
vue v-html React dangerouslySetInnerHTML
httponly防止用户窃取cookie

5. CSP策略
我们能够规定，我们的网站只接受我们指定的请求资源，本质是白名单策略。通过设置HTTP头信息或meta元素进行定义

<meta http-equiv="content-security-policy" contnt="default-src 'self'" />

response.header('Content-Security-Policy': "default-src 'self'")




# csrf攻击

httpOnly解决

samesite解决



