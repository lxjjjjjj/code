[原文链接](https://juejin.cn/post/7076743589505531917)
[webpack的讲解](https://webpack.wuhaolin.cn/1%E5%85%A5%E9%97%A8/1-2%E5%B8%B8%E8%A7%81%E7%9A%84%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%AF%B9%E6%AF%94.html)
[webpack官方对optimization的说明](https://webpack.docschina.org/configuration/optimization/)

speed-measure-webpack-plugin插件可以检测每个打包步骤花费的时间是多少来做优化

# 多入口部署项目
```
var fs = require('fs');
var path = require('path');
var webpack = require('webpack');
var VueLoaderPlugin = require('vue-loader/lib/plugin')
// const { VueLoaderPlugin } = require('vue-loader')
var MiniCssExtractPlugin = require('mini-css-extract-plugin');
var UglifyJsPlugin = require('uglifyjs-webpack-plugin');
var OptimizeCSSAssetsPlugin = require('optimize-css-assets-webpack-plugin');
var webpackPluginBmfeSourcemap = require('@banmafe/webpack-plugin-bmfe-sourcemap')
var recursiveReaddirSync = require('recursive-readdir-sync');
const WorkboxPlugin = require('workbox-webpack-plugin');

var isProduction = process.env.NODE_ENV == 'production';

// module.exports = allEntries.map(entry => {
module.exports = pathEntries(envPaths()).map(function (entryFile) {
  var entryPath = path.dirname(entryFile);
  var entryDir = path.relative(path.join(__dirname, 'src'), entryPath);

  var entryName = path.basename(entryFile, path.extname(entryFile));
  var chunkName = entryName.replace('-entry', '-chunk');
  var vendorName = entryName.replace('-entry', '-vendor');

  // 如果是公共 includes 文件, 则不拆分文件
  var isIncludes = entryDir == 'inc';
  // 如果是瞪羚目录，需要打包sw文件
  var isSw = ['gazelle'].indexOf(entryDir) >= 0;

  var threadLoader = require('thread-loader');
  var jsWorkerPool = {
    // options
    // 产生的 worker 的数量，默认是 (cpu 核心数 - 1)
    // 当 require('os').cpus() 是 undefined 时，则为 1
    workers: 2,
    // 闲置时定时删除 worker 进程
    // 默认为 500ms
    // 可以设置为无穷大， 这样在监视模式(--watch)下可以保持 worker 持续存在
    poolTimeout: 2000
  };
  var cssWorkerPool = {
    // 一个 worker 进程中并行执行工作的数量
    // 默认为 20
    workerParallelJobs: 2,
    poolTimeout: 2000
  };

  threadLoader.warmup(jsWorkerPool, ['babel-loader']);
  threadLoader.warmup(cssWorkerPool, ['css-loader', 'postcss-loader']);

  return {
    mode: process.env.NODE_ENV || 'development',
    devServer: {
      port: 7070,
      stats: {
        errors: true,
        warnings: true
      },
      contentBase: path.join(__dirname, 'dist')
    },
    devtool: isProduction ? '' : 'cheap-module-eval-source-map',
    entry: function () {
      var result = {};
      result[entryName] = entryFile;
      return result;
    },
    output: {
      path: path.join(__dirname, '/dist', entryDir),
      publicPath: path.join('/dist', entryDir) + '/',
      filename: '[name].pack' + (isProduction ? '.[chunkhash:8]' : '') + '.js',
      chunkFilename: chunkName + '.[chunkhash:8].js'
    },
    resolve: {
      alias: {
        '@src': path.resolve(__dirname, 'src'),
        '@lib': path.resolve(__dirname, 'static/lib'),
        '@ui': path.resolve(__dirname, 'static/ui'),
        '@modules': path.resolve(__dirname, 'static/modules'),
        '@components': path.resolve(__dirname, 'static/components'),
        '@node_modules': path.resolve(__dirname, 'node_modules')
      },
      extensions: ['.js', '.vue', '.ts', '.tsx']
    },

    optimization: {
      splitChunks: isIncludes ? false : (function () {
        // if(!parseVendors(entryFile).length){
        //   return false;
        // }
        return {
          cacheGroups: {
            default: false,
            vendor: {
              test: /[\\/]node_modules[\\/]/,
              minSize: 1, // 确保拆分 vendor
              priority: 0,
              name: vendorName,
              filename: vendorName + '.pack' + (isProduction ? '.[contenthash:12]' : '') + '.js',
              chunks: 'initial',
              reuseExistingChunk: true
            }
          }
        }
      })(),
      namedChunks: true // enable webpackChunkName in production mode, see https://github.com/webpack/webpack/issues/6876
    },
    externals: {
      'lime': 'lime'
    },
    plugins: [
      new VueLoaderPlugin(),
      isSw ? new WorkboxPlugin.InjectManifest({
        swSrc: path.resolve(__dirname, 'sw.dev.js'),
        swDest: path.resolve(__dirname, 'dist/' + entryDir + '/sw.js')
      }) : null,
      isIncludes ? new MiniCssExtractPlugin({
        filename: '[name].pack' + (isProduction ? '.[contenthash:8]' : '') + '.css'
      }) : null,
      new webpack.HashedModuleIdsPlugin({
        hashFunction: 'sha256',
        hashDigest: 'hex',
        hashDigestLength: 8
      }),
      new OptimizeCSSAssetsPlugin({}), // 加上后减小2k 178k -> 176k
      /* isProduction  ? new webpack.SourceMapDevToolPlugin({
          filename: '[hash].js.map',
          publicPath: 'https://s3plus.sankuai.com/v1/mss_0ddf9b250a1b4db28fb1d9ad764b2853/sourcemap/',
        }): null,
        isProduction ? new webpackPluginBmfeSourcemap({
          accessKeyId: '619c2185a5e8414d926c90a039a24345',
          accessKeySecret: '863b5df2ccd446aba04da6374d369134',
          bucket: 'sourcemap'
        }) : null,*/
    ].filter(Boolean),
    module: {
      rules: [
        {
          test: /\.s?css$/,
          oneOf: [
            {
              loader: [
                isIncludes ? MiniCssExtractPlugin.loader : { loader: 'style-loader' },
                {
                  loader: 'thread-loader',
                  options: cssWorkerPool
                },
                { loader: 'css-loader', options: { minimize: true }},
                { loader: 'sass-loader' }
              ]
            }
          ]
        },
        {
          test: /\.(png|jpg|jpeg|gif)$/,
          loader: 'url-loader',
          options: {
            limit: 1,
            name: entryDir + '/images/[hash:8].[ext]'
          }
        },
        {
          test: /\.(svg|eot|ttf|woff2?)$/,
          loader: 'url-loader',
          options: {
            limit: 5000,
            name: entryDir + '/fonts/[hash:8].[ext]'
          }
        },
        {
          test: /\.vue$/,
          loader: 'vue-loader'
        },
        {
          test: /\.(js|ts)x?$/,
          exclude: /(node_modules)/,
          use: [
            {
              loader: 'thread-loader',
              options: jsWorkerPool
            },
            'babel-loader'
          ]
        }
      ]
    }
  }
})

function pathEntries(dirs) {
  return dirs.reduce(function (entries, dir) {
    var dirPath = path.join(__dirname, "src", dir)

    // 如果传入的是一个入口文件, 则直接放入数组中返回
    if (dirPath.match(/-entry\.[tj]sx?$/)) {
      if (fs.existsSync(dirPath) && fs.statSync(dirPath).isFile()) {
        return entries.concat(dirPath);
      }
      var tsEntry = dirPath.replace(/js$/, 'ts');
      if (fs.existsSync(dirPath) && fs.statSync(dirPath).isFile()) {
        return entries.concat(dirPath);
      }
      var tsxEntry = dirPath.replace(/js$/, 'tsx');
      if (fs.existsSync(tsxEntry) && fs.statSync(tsxEntry).isFile()) {
        return entries.concat(tsxEntry);
      }
      return entries;
    }

    // 如果不是入口文件, 则读取目录下的所有入口文件
    // 不允许嵌套目录, 只取单层目录下的入口文件, 子目录下的不管
    return entries.concat(fs.readdirSync(dirPath).filter(function (item) {
      return item.match(/-entry\.[tj]sx?$/) && fs.statSync(path.join(dirPath, item)).isFile();
    }).map(function (item) {
      // 返回全路径
      return path.join(dirPath, item);
    }));
  }, []);
};

function envPaths() {
  var paths = ['DATA_PROJECT_PATH', 'DIR', 'dir'].reduce(function (dirs, key) {
    if (!process.env[key]) {
      return dirs;
    }

    return dirs.concat(process.env[key].split(',').filter(function (name) {
      // 目录或者是入口js存在的情况
      return fs.existsSync(path.join(__dirname, 'src', name)) ||
        // 入口ts存在的情况
        fs.existsSync(path.join(__dirname, 'src', name.replace(/js$/, 'ts'))) ||
        // 入口tsx存在的情况
        fs.existsSync(path.join(PAGE_PATH, name.replace(/js$/, 'tsx')))
    }));
  }, []);

  if (!paths.length) {
    paths.push("fluorite")
    console.info('You may should set DATA_PROJECT_PATH or DIR environment variable');
  }

  return paths;
}

```


# 使用插件解释

## uglifyjs-webpack-plugin
[官网解释](https://webpack.docschina.org/plugins/uglifyjs-webpack-plugin/)
用于压缩js代码，支持配置哪些chunk不被压缩，并且可以开启缓存和多线程压缩

## mini-css-extract-plugin
[官网解释](https://webpack.docschina.org/plugins/mini-css-extract-plugin/)
本插件会将 CSS 提取到单独的文件中，为每个包含 CSS 的 JS 文件创建一个 CSS 文件，并且支持 CSS 和 SourceMaps 的按需加载。

本插件基于 webpack v5 的新特性构建，并且需要 webpack 5 才能正常工作。

与 extract-text-webpack-plugin 相比：

异步加载
没有重复的编译（性能）
更容易使用
特别针对 CSS 开发

如果你从 webpack 入口处导入 CSS 或者在 初始 chunk 中引入 style， mini-css-extract-plugin 则不会将这些 CSS 加载到页面中。请使用 html-webpack-plugin 自动生成 link 标签或者在创建 index.html 文件时使用 link 标签。

## optimize-css-assets-webpack-plugin
压缩css体积 https://webpack.js.org/plugins/css-minimizer-webpack-plugin/
# webpack的optimization

## chunkIds
[webpack官方解释](https://webpack.docschina.org/configuration/optimization/#optimizationchunkids)
chunkIds: "named", // 指定打包过程中的chunkId，设为named会生成可读性好的chunkId，便于debug
## minimizer压缩功能

# 拆包打包优化(splitchunks)
webpack5 本身默认开启压缩功能，有默认的压缩插件。
但可以通过 minimizer 配置项来使用一个或多个其它压缩插件覆盖默认压缩工具。
```
const UglifyJsPlugin = require('uglifyjs-webpack-plugin')
const OptimizeCssAssetsPlugin = require('optimize-css-assets-webpack-plugin')

module.exports = {
  optimization: {
    minimizer: [
      new UglifyJsPlugin({
        ...
      }),
      new OptimizeCssAssetsPlugin({
        ...
      })
    ],
  },
};
```

## splitchunks属性说明

maxAsyncRequests  按需加载时的最大并行请求数。

maxInitialRequests  入口点的最大并行请求数。

minChunks  要提取的chunks最少被引用多少次

minSize  生成 chunk 的最小体积（以 bytes 为单位）。

minSizeReduction 生成 chunk 所需的主 chunk（bundle）的最小体积（以字节为单位）缩减。这意味着如果分割成一个 chunk 并没有减少主 chunk（bundle）的给定字节数，它将不会被分割，即使它满足 splitChunks.minSize

enforceSizeThreshold 强制执行拆分的体积阈值，满足此条件后其他限制（minRemainingSize，maxAsyncRequests，maxInitialRequests）将被忽略
```
{
    minSize: 0, // 默认30000（30kb），但是demo中的文件都很小，minSize设为0，让每个文件都满足大小条件, 超过minSize体积的包才会被打包到下面cacheGroup的chunk中
    cacheGroups: {
        commons: {
          chunks: "initial",
		  // 这表明将选择哪些 chunk 进行优化。当提供一个字符串，有效值为 all，async(异步) 和 initial(同步)。设置为 all 可能特别强大，因为这意味着 chunk 可以在异步和非异步 chunk 之间共享。
		//   name: "commons",
          minChunks: 2, // 打包到commons的cacheGroups的分包需要满足至少被多少个包引入的规则 因为utility1只被pageA引入，所以不会打包到commons chunk 中
          maxInitialRequests: 5, // 默认为3 每个入口chunk最多由几个chunk分包组成，由于一开始设置的是3 所以即使utility3被引入了2两次 也没有被单独打包到commons chunk中 所以改成5看看utility3的打包情况
		  // 可以看到将maxInitialRequests改成5之后 pageB内有了utility3的分包
        },
        vendor: {
          test: /node_modules/,
          chunks: "initial",
          name: "vendor", 
		// 从打包结果上可以看出node_modules中的vendor1 和 vendor2 被打包到了同一个chunk vendor中，但是上面的common分包下的utility2和utility3却被打包成了commons-utility2_js.js 和 commons-utility3_js.js
		// 可以看出是因为我们在vendor包中加了name属性 如果我们将vendor中的那么属性去掉
		// 那么vendor1 和 vendor2 将被打包成 vendor-node_modules_vendor1_js.js 和 vendor-node_modules_vendor2_js.js
		// 如果给commons添加了name commons 那么commons中将会打包utility2和utility3被pageA pageB pageC引用
        },
      },
}
```
```
var path = require("path");
// 如果项目仅仅只在pageA中引入async1 和 async2 那么 utility1 不会被单独打包出来
// 因为：utility1.js 同时被 pageA.js，async1.js，async2.js 三个模块引用，照理应该命中 commons 缓存组的规则，从而被单独提取成一个 chunk，
// 然而结果是它依然打包在 pageA.js 中。这是因为 async1.js，async2.js 都是 pageA.js 的懒加载模块，
// 而 pageA.js 同步引用了 utility1.js，所以在加载 async1.js，async2.js 时 utility1.js 已经有了，直接拿来用即可，所以就没必要提出一个新的 chunk，白白增加一个请求。
// 如果想要utility1被单独提取出来可以在pageB页面中异步加载async1和async2
module.exports = {
	mode: "development",
	// mode: "production",
	entry: {
		pageA: "./pageA",
		pageB: "./pageB",
		pageC: "./pageC"
	},
	optimization: {
		chunkIds: "named",
		splitChunks: {
			minSize: 0,
			name:false,
			cacheGroups: {
				commons: {
					chunks: "all",//加入按需加载后，设为all将所有模块包括在优化范围内
					// name: "commons",
					minChunks: 2,
					maxInitialRequests: 5, // 默认为3，无法满足我们的分包数量
				},
				vendor: {
					test: /node_modules/,
					chunks: "initial",
					name: "vendor",
					// priority: 10,
					// enforce: true
				}
			}
		}
	},
	output: {
		path: path.join(__dirname, "dist"),
		filename: "[name].js",
	}
};

```
