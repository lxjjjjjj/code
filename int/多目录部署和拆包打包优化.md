[原文链接](https://juejin.cn/post/7076743589505531917)
[webpack官方对optimization的说明](https://webpack.docschina.org/configuration/optimization/)

# 多入口部署项目
```
var fs = require('fs');
var path = require('path');
var webpack = require('webpack');
var VueLoaderPlugin = require('vue-loader/lib/plugin')
// const { VueLoaderPlugin } = require('vue-loader')
var MiniCssExtractPlugin = require('mini-css-extract-plugin');
var UglifyJsPlugin = require('uglifyjs-webpack-plugin');
var OptimizeCSSAssetsPlugin = require('optimize-css-assets-webpack-plugin');
var webpackPluginBmfeSourcemap = require('@banmafe/webpack-plugin-bmfe-sourcemap')
var recursiveReaddirSync = require('recursive-readdir-sync');
const WorkboxPlugin = require('workbox-webpack-plugin');

var isProduction = process.env.NODE_ENV == 'production';

// module.exports = allEntries.map(entry => {
module.exports = pathEntries(envPaths()).map(function (entryFile) {
  var entryPath = path.dirname(entryFile);
  var entryDir = path.relative(path.join(__dirname, 'src'), entryPath);

  var entryName = path.basename(entryFile, path.extname(entryFile));
  var chunkName = entryName.replace('-entry', '-chunk');
  var vendorName = entryName.replace('-entry', '-vendor');

  // 如果是公共 includes 文件, 则不拆分文件
  var isIncludes = entryDir == 'inc';
  // 如果是瞪羚目录，需要打包sw文件
  var isSw = ['gazelle'].indexOf(entryDir) >= 0;

  var threadLoader = require('thread-loader');
  var jsWorkerPool = {
    // options
    // 产生的 worker 的数量，默认是 (cpu 核心数 - 1)
    // 当 require('os').cpus() 是 undefined 时，则为 1
    workers: 2,
    // 闲置时定时删除 worker 进程
    // 默认为 500ms
    // 可以设置为无穷大， 这样在监视模式(--watch)下可以保持 worker 持续存在
    poolTimeout: 2000
  };
  var cssWorkerPool = {
    // 一个 worker 进程中并行执行工作的数量
    // 默认为 20
    workerParallelJobs: 2,
    poolTimeout: 2000
  };

  threadLoader.warmup(jsWorkerPool, ['babel-loader']);
  threadLoader.warmup(cssWorkerPool, ['css-loader', 'postcss-loader']);

  return {
    mode: process.env.NODE_ENV || 'development',
    devServer: {
      port: 7070,
      stats: {
        errors: true,
        warnings: true
      },
      contentBase: path.join(__dirname, 'dist')
    },
    devtool: isProduction ? '' : 'cheap-module-eval-source-map',
    entry: function () {
      var result = {};
      result[entryName] = entryFile;
      return result;
    },
    output: {
      path: path.join(__dirname, '/dist', entryDir),
      publicPath: path.join('/dist', entryDir) + '/',
      filename: '[name].pack' + (isProduction ? '.[chunkhash:8]' : '') + '.js',
      chunkFilename: chunkName + '.[chunkhash:8].js'
    },
    resolve: {
      alias: {
        '@src': path.resolve(__dirname, 'src'),
        '@lib': path.resolve(__dirname, 'static/lib'),
        '@ui': path.resolve(__dirname, 'static/ui'),
        '@modules': path.resolve(__dirname, 'static/modules'),
        '@components': path.resolve(__dirname, 'static/components'),
        '@node_modules': path.resolve(__dirname, 'node_modules')
      },
      extensions: ['.js', '.vue', '.ts', '.tsx']
    },

    optimization: {
      splitChunks: isIncludes ? false : (function () {
        // if(!parseVendors(entryFile).length){
        //   return false;
        // }
        return {
          cacheGroups: {
            default: false,
            vendor: {
              test: /[\\/]node_modules[\\/]/,
              minSize: 1, // 确保拆分 vendor
              priority: 0,
              name: vendorName,
              filename: vendorName + '.pack' + (isProduction ? '.[contenthash:12]' : '') + '.js',
              chunks: 'initial',
              reuseExistingChunk: true
            }
          }
        }
      })(),
      namedChunks: true // enable webpackChunkName in production mode, see https://github.com/webpack/webpack/issues/6876
    },
    externals: {
      'lime': 'lime'
    },
    plugins: [
      new VueLoaderPlugin(),
      isSw ? new WorkboxPlugin.InjectManifest({
        swSrc: path.resolve(__dirname, 'sw.dev.js'),
        swDest: path.resolve(__dirname, 'dist/' + entryDir + '/sw.js')
      }) : null,
      isIncludes ? new MiniCssExtractPlugin({
        filename: '[name].pack' + (isProduction ? '.[contenthash:8]' : '') + '.css'
      }) : null,
      new webpack.HashedModuleIdsPlugin({
        hashFunction: 'sha256',
        hashDigest: 'hex',
        hashDigestLength: 8
      }),
      new OptimizeCSSAssetsPlugin({}), // 加上后减小2k 178k -> 176k
      /* isProduction  ? new webpack.SourceMapDevToolPlugin({
          filename: '[hash].js.map',
          publicPath: 'https://s3plus.sankuai.com/v1/mss_0ddf9b250a1b4db28fb1d9ad764b2853/sourcemap/',
        }): null,
        isProduction ? new webpackPluginBmfeSourcemap({
          accessKeyId: '619c2185a5e8414d926c90a039a24345',
          accessKeySecret: '863b5df2ccd446aba04da6374d369134',
          bucket: 'sourcemap'
        }) : null,*/
    ].filter(Boolean),
    module: {
      rules: [
        {
          test: /\.s?css$/,
          oneOf: [
            {
              loader: [
                isIncludes ? MiniCssExtractPlugin.loader : { loader: 'style-loader' },
                {
                  loader: 'thread-loader',
                  options: cssWorkerPool
                },
                { loader: 'css-loader', options: { minimize: true }},
                { loader: 'sass-loader' }
              ]
            }
          ]
        },
        {
          test: /\.(png|jpg|jpeg|gif)$/,
          loader: 'url-loader',
          options: {
            limit: 1,
            name: entryDir + '/images/[hash:8].[ext]'
          }
        },
        {
          test: /\.(svg|eot|ttf|woff2?)$/,
          loader: 'url-loader',
          options: {
            limit: 5000,
            name: entryDir + '/fonts/[hash:8].[ext]'
          }
        },
        {
          test: /\.vue$/,
          loader: 'vue-loader'
        },
        {
          test: /\.(js|ts)x?$/,
          exclude: /(node_modules)/,
          use: [
            {
              loader: 'thread-loader',
              options: jsWorkerPool
            },
            'babel-loader'
          ]
        }
      ]
    }
  }
})

function pathEntries(dirs) {
  return dirs.reduce(function (entries, dir) {
    var dirPath = path.join(__dirname, "src", dir)

    // 如果传入的是一个入口文件, 则直接放入数组中返回
    if (dirPath.match(/-entry\.[tj]sx?$/)) {
      if (fs.existsSync(dirPath) && fs.statSync(dirPath).isFile()) {
        return entries.concat(dirPath);
      }
      var tsEntry = dirPath.replace(/js$/, 'ts');
      if (fs.existsSync(dirPath) && fs.statSync(dirPath).isFile()) {
        return entries.concat(dirPath);
      }
      var tsxEntry = dirPath.replace(/js$/, 'tsx');
      if (fs.existsSync(tsxEntry) && fs.statSync(tsxEntry).isFile()) {
        return entries.concat(tsxEntry);
      }
      return entries;
    }

    // 如果不是入口文件, 则读取目录下的所有入口文件
    // 不允许嵌套目录, 只取单层目录下的入口文件, 子目录下的不管
    return entries.concat(fs.readdirSync(dirPath).filter(function (item) {
      return item.match(/-entry\.[tj]sx?$/) && fs.statSync(path.join(dirPath, item)).isFile();
    }).map(function (item) {
      // 返回全路径
      return path.join(dirPath, item);
    }));
  }, []);
};

function envPaths() {
  var paths = ['DATA_PROJECT_PATH', 'DIR', 'dir'].reduce(function (dirs, key) {
    if (!process.env[key]) {
      return dirs;
    }

    return dirs.concat(process.env[key].split(',').filter(function (name) {
      // 目录或者是入口js存在的情况
      return fs.existsSync(path.join(__dirname, 'src', name)) ||
        // 入口ts存在的情况
        fs.existsSync(path.join(__dirname, 'src', name.replace(/js$/, 'ts'))) ||
        // 入口tsx存在的情况
        fs.existsSync(path.join(PAGE_PATH, name.replace(/js$/, 'tsx')))
    }));
  }, []);

  if (!paths.length) {
    paths.push("fluorite")
    console.info('You may should set DATA_PROJECT_PATH or DIR environment variable');
  }

  return paths;
}

```
# webpack的optimization

## chunkIds
[webpack官方解释](https://webpack.docschina.org/configuration/optimization/#optimizationchunkids)
chunkIds: "named", // 指定打包过程中的chunkId，设为named会生成可读性好的chunkId，便于debug

## runtimeChunk

就是将当前chunk引入其他chunk的hash单独打包成一个 runtimeChunk 文件

true/multiple：针对每个入口打包一个runtime文件
single：统一打包一个共享的runtime文件
对象：其 name 属性决定runtimeChunk的名称，可以是函数也可以是字符串
默认值是 false：每个入口 chunk 中直接嵌入 runtime

true/multiple：针对每个入口打包一个runtime文件
single：统一打包一个共享的runtime文件
对象：其 name 属性决定runtimeChunk的名称，可以是函数也可以是字符串
默认值是 false：每个入口 chunk 中直接嵌入 runtime

```
index.js中，动态引入 a.js
import (/*webpackChunkName:'add'*/'./a.js').then(()=>{
  ...
})

module.exports = {
   ...
   entry: {
        mainname: './src/index.js'
    },
    output:{
        filename:'[name].[contenthash:10].js',
        path:resolve(__dirname,'dist'),
        //对import引入的文件做名字处理，增加contenthash
        chunkFilename:'[name].[contenthash:10]_chunk.js'
    },
    splitChunks:{
      chunks:"all" // 这里采用其他值亦可以
      // 其他的采用默认值
    }
}
这时候我们打包看看，会发现打包出来两个文件
mainame.xxx.js'是因为 entry里key用的是 'mainname'，这个值传到了 filename:'[name].[contenthash:10].js',中的[name]里
'add.xxx.js'是因为动态引入的时候，/*webpackChunkName:'add'*/这里用了 'add'，这个值传到了chunkFilename:'[name].[contenthash:10]_chunk.js'中的[name]里


这时候我们修改a.js内容，重新打包，这时候发现两个文件名都改变了

其原因如下：
由于 a.js 文件内容改变，所以它的chunk改变（因为使用了chunkContent）。而在'mainame.xxx.js' 文件里，保存了 add 文件的hash值！因此'mainame.xxx.js' 内容也改变了，所以它的chunk名也变了

很明显，这样是不合理的。webpack想出了一个方法，就是把hash值单独进行打包，这就用到了runtimeChunk


增加配置

//将当前模块记录其他模块的hash单独打包到一个文件runtime
//打包后，会生成runtime文件
//如果更改a.js文件，新生成的文件为add.js  和 runtime文件，mainname.js没变
runtimeChunk:{
    name:entrypoint=>`runtime-${entrypoint.name}`
}

这样打包之后发现 更改add文件内容 main文件的hash不会改变 main文件的runtimechunk文件的hash会变化
```
## minimizer压缩功能

# 拆包打包优化(splitchunks)
webpack5 本身默认开启压缩功能，有默认的压缩插件。
但可以通过 minimizer 配置项来使用一个或多个其它压缩插件覆盖默认压缩工具。
```
const UglifyJsPlugin = require('uglifyjs-webpack-plugin')
const OptimizeCssAssetsPlugin = require('optimize-css-assets-webpack-plugin')

module.exports = {
  optimization: {
    minimizer: [
      new UglifyJsPlugin({
        ...
      }),
      new OptimizeCssAssetsPlugin({
        ...
      })
    ],
  },
};
```
## sideEffect
告知 webpack 要不要去识别该项目代码中是否有副作用，从而为Tree-shaking提供更大的压缩空间。
这里的副作用指的是模块执行时除了导出成员之外所做的事情。
开启了 optimization.sideEffects 配置后，webpack在打包时就会先检查需要打包的项目的 package.json 中有没有sideEffects的标识，以此来判断这个模块是不是有副作用。如果这个模块没有副作用，这些没被用到的模块就不会被打包。（这个特性在production模式下会自动开启）
例如：在package.json中配置以下"sideEffects":false 表示整个项目没有副作用，那项目实际出现的一些未使用代码，webpack就不会再打包了
如果该项目中确实有一些副作用，即使没有使用，也不想webpack在打包时删掉，那就以数组的方式提供

## splitchunks属性说明

maxAsyncRequests  按需加载时的最大并行请求数。

maxInitialRequests  入口点的最大并行请求数。

minChunks  要提取的chunks最少被引用多少次

minSize  生成 chunk 的最小体积（以 bytes 为单位）。

minSizeReduction 生成 chunk 所需的主 chunk（bundle）的最小体积（以字节为单位）缩减。这意味着如果分割成一个 chunk 并没有减少主 chunk（bundle）的给定字节数，它将不会被分割，即使它满足 splitChunks.minSize

enforceSizeThreshold 强制执行拆分的体积阈值，满足此条件后其他限制（minRemainingSize，maxAsyncRequests，maxInitialRequests）将被忽略
```
{
    minSize: 0, // 默认30000（30kb），但是demo中的文件都很小，minSize设为0，让每个文件都满足大小条件, 超过minSize体积的包才会被打包到下面cacheGroup的chunk中
    cacheGroups: {
        commons: {
          chunks: "initial",
		  // 这表明将选择哪些 chunk 进行优化。当提供一个字符串，有效值为 all，async(异步) 和 initial(同步)。设置为 all 可能特别强大，因为这意味着 chunk 可以在异步和非异步 chunk 之间共享。
		//   name: "commons",
          minChunks: 2, // 打包到commons的cacheGroups的分包需要满足至少被多少个包引入的规则 因为utility1只被pageA引入，所以不会打包到commons chunk 中
          maxInitialRequests: 5, // 默认为3 每个入口chunk最多由几个chunk分包组成，由于一开始设置的是3 所以即使utility3被引入了2两次 也没有被单独打包到commons chunk中 所以改成5看看utility3的打包情况
		  // 可以看到将maxInitialRequests改成5之后 pageB内有了utility3的分包
        },
        vendor: {
          test: /node_modules/,
          chunks: "initial",
          name: "vendor", 
		// 从打包结果上可以看出node_modules中的vendor1 和 vendor2 被打包到了同一个chunk vendor中，但是上面的common分包下的utility2和utility3却被打包成了commons-utility2_js.js 和 commons-utility3_js.js
		// 可以看出是因为我们在vendor包中加了name属性 如果我们将vendor中的那么属性去掉
		// 那么vendor1 和 vendor2 将被打包成 vendor-node_modules_vendor1_js.js 和 vendor-node_modules_vendor2_js.js
		// 如果给commons添加了name commons 那么commons中将会打包utility2和utility3被pageA pageB pageC引用
        },
      },
}
```
```
var path = require("path");
// 如果项目仅仅只在pageA中引入async1 和 async2 那么 utility1 不会被单独打包出来
// 因为：utility1.js 同时被 pageA.js，async1.js，async2.js 三个模块引用，照理应该命中 commons 缓存组的规则，从而被单独提取成一个 chunk，
// 然而结果是它依然打包在 pageA.js 中。这是因为 async1.js，async2.js 都是 pageA.js 的懒加载模块，
// 而 pageA.js 同步引用了 utility1.js，所以在加载 async1.js，async2.js 时 utility1.js 已经有了，直接拿来用即可，所以就没必要提出一个新的 chunk，白白增加一个请求。
// 如果想要utility1被单独提取出来可以在pageB页面中异步加载async1和async2
module.exports = {
	mode: "development",
	// mode: "production",
	entry: {
		pageA: "./pageA",
		pageB: "./pageB",
		pageC: "./pageC"
	},
	optimization: {
		chunkIds: "named",
		splitChunks: {
			minSize: 0,
			name:false,
			cacheGroups: {
				commons: {
					chunks: "all",//加入按需加载后，设为all将所有模块包括在优化范围内
					// name: "commons",
					minChunks: 2,
					maxInitialRequests: 5, // 默认为3，无法满足我们的分包数量
				},
				vendor: {
					test: /node_modules/,
					chunks: "initial",
					name: "vendor",
					// priority: 10,
					// enforce: true
				}
			}
		}
	},
	output: {
		path: path.join(__dirname, "dist"),
		filename: "[name].js",
	}
};

```
