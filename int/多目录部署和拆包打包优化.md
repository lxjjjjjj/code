[原文链接](https://juejin.cn/post/7076743589505531917)
[webpack官方对optimization的说明](https://webpack.docschina.org/configuration/optimization/)

# webpack的optimization

## chunkIds
[webpack官方解释](https://webpack.docschina.org/configuration/optimization/#optimizationchunkids)
chunkIds: "named", // 指定打包过程中的chunkId，设为named会生成可读性好的chunkId，便于debug

## runtimeChunk

就是将当前chunk引入其他chunk的hash单独打包成一个 runtimeChunk 文件

true/multiple：针对每个入口打包一个runtime文件
single：统一打包一个共享的runtime文件
对象：其 name 属性决定runtimeChunk的名称，可以是函数也可以是字符串
默认值是 false：每个入口 chunk 中直接嵌入 runtime

true/multiple：针对每个入口打包一个runtime文件
single：统一打包一个共享的runtime文件
对象：其 name 属性决定runtimeChunk的名称，可以是函数也可以是字符串
默认值是 false：每个入口 chunk 中直接嵌入 runtime

```
index.js中，动态引入 a.js
import (/*webpackChunkName:'add'*/'./a.js').then(()=>{
  ...
})

module.exports = {
   ...
   entry: {
        mainname: './src/index.js'
    },
    output:{
        filename:'[name].[contenthash:10].js',
        path:resolve(__dirname,'dist'),
        //对import引入的文件做名字处理，增加contenthash
        chunkFilename:'[name].[contenthash:10]_chunk.js'
    },
    splitChunks:{
      chunks:"all" // 这里采用其他值亦可以
      // 其他的采用默认值
    }
}
这时候我们打包看看，会发现打包出来两个文件
mainame.xxx.js'是因为 entry里key用的是 'mainname'，这个值传到了 filename:'[name].[contenthash:10].js',中的[name]里
'add.xxx.js'是因为动态引入的时候，/*webpackChunkName:'add'*/这里用了 'add'，这个值传到了chunkFilename:'[name].[contenthash:10]_chunk.js'中的[name]里


这时候我们修改a.js内容，重新打包，这时候发现两个文件名都改变了

其原因如下：
由于 a.js 文件内容改变，所以它的chunk改变（因为使用了chunkContent）。而在'mainame.xxx.js' 文件里，保存了 add 文件的hash值！因此'mainame.xxx.js' 内容也改变了，所以它的chunk名也变了

很明显，这样是不合理的。webpack想出了一个方法，就是把hash值单独进行打包，这就用到了runtimeChunk


增加配置

//将当前模块记录其他模块的hash单独打包到一个文件runtime
//打包后，会生成runtime文件
//如果更改a.js文件，新生成的文件为add.js  和 runtime文件，mainname.js没变
runtimeChunk:{
    name:entrypoint=>`runtime-${entrypoint.name}`
}

这样打包之后发现 更改add文件内容 main文件的hash不会改变 main文件的runtimechunk文件的hash会变化
```
## minimizer压缩功能

# 拆包打包优化(splitchunks)
webpack5 本身默认开启压缩功能，有默认的压缩插件。
但可以通过 minimizer 配置项来使用一个或多个其它压缩插件覆盖默认压缩工具。
```
const UglifyJsPlugin = require('uglifyjs-webpack-plugin')
const OptimizeCssAssetsPlugin = require('optimize-css-assets-webpack-plugin')

module.exports = {
  optimization: {
    minimizer: [
      new UglifyJsPlugin({
        ...
      }),
      new OptimizeCssAssetsPlugin({
        ...
      })
    ],
  },
};
```
## sideEffect
告知 webpack 要不要去识别该项目代码中是否有副作用，从而为Tree-shaking提供更大的压缩空间。
这里的副作用指的是模块执行时除了导出成员之外所做的事情。
开启了 optimization.sideEffects 配置后，webpack在打包时就会先检查需要打包的项目的 package.json 中有没有sideEffects的标识，以此来判断这个模块是不是有副作用。如果这个模块没有副作用，这些没被用到的模块就不会被打包。（这个特性在production模式下会自动开启）
例如：在package.json中配置以下"sideEffects":false 表示整个项目没有副作用，那项目实际出现的一些未使用代码，webpack就不会再打包了
如果该项目中确实有一些副作用，即使没有使用，也不想webpack在打包时删掉，那就以数组的方式提供

## splitchunks属性说明

maxAsyncRequests  按需加载时的最大并行请求数。

maxInitialRequests  入口点的最大并行请求数。

minChunks  要提取的chunks最少被引用多少次

minSize  生成 chunk 的最小体积（以 bytes 为单位）。

minSizeReduction 生成 chunk 所需的主 chunk（bundle）的最小体积（以字节为单位）缩减。这意味着如果分割成一个 chunk 并没有减少主 chunk（bundle）的给定字节数，它将不会被分割，即使它满足 splitChunks.minSize

enforceSizeThreshold 强制执行拆分的体积阈值，满足此条件后其他限制（minRemainingSize，maxAsyncRequests，maxInitialRequests）将被忽略
```
{
    minSize: 0, // 默认30000（30kb），但是demo中的文件都很小，minSize设为0，让每个文件都满足大小条件, 超过minSize体积的包才会被打包到下面cacheGroup的chunk中
    cacheGroups: {
        commons: {
          chunks: "initial",
		  // 这表明将选择哪些 chunk 进行优化。当提供一个字符串，有效值为 all，async(异步) 和 initial(同步)。设置为 all 可能特别强大，因为这意味着 chunk 可以在异步和非异步 chunk 之间共享。
		//   name: "commons",
          minChunks: 2, // 打包到commons的cacheGroups的分包需要满足至少被多少个包引入的规则 因为utility1只被pageA引入，所以不会打包到commons chunk 中
          maxInitialRequests: 5, // 默认为3 每个入口chunk最多由几个chunk分包组成，由于一开始设置的是3 所以即使utility3被引入了2两次 也没有被单独打包到commons chunk中 所以改成5看看utility3的打包情况
		  // 可以看到将maxInitialRequests改成5之后 pageB内有了utility3的分包
        },
        vendor: {
          test: /node_modules/,
          chunks: "initial",
          name: "vendor", 
		// 从打包结果上可以看出node_modules中的vendor1 和 vendor2 被打包到了同一个chunk vendor中，但是上面的common分包下的utility2和utility3却被打包成了commons-utility2_js.js 和 commons-utility3_js.js
		// 可以看出是因为我们在vendor包中加了name属性 如果我们将vendor中的那么属性去掉
		// 那么vendor1 和 vendor2 将被打包成 vendor-node_modules_vendor1_js.js 和 vendor-node_modules_vendor2_js.js
		// 如果给commons添加了name commons 那么commons中将会打包utility2和utility3被pageA pageB pageC引用
        },
      },
}
```
```
var path = require("path");
// 如果项目仅仅只在pageA中引入async1 和 async2 那么 utility1 不会被单独打包出来
// 因为：utility1.js 同时被 pageA.js，async1.js，async2.js 三个模块引用，照理应该命中 commons 缓存组的规则，从而被单独提取成一个 chunk，
// 然而结果是它依然打包在 pageA.js 中。这是因为 async1.js，async2.js 都是 pageA.js 的懒加载模块，
// 而 pageA.js 同步引用了 utility1.js，所以在加载 async1.js，async2.js 时 utility1.js 已经有了，直接拿来用即可，所以就没必要提出一个新的 chunk，白白增加一个请求。
// 如果想要utility1被单独提取出来可以在pageB页面中异步加载async1和async2
module.exports = {
	mode: "development",
	// mode: "production",
	entry: {
		pageA: "./pageA",
		pageB: "./pageB",
		pageC: "./pageC"
	},
	optimization: {
		chunkIds: "named",
		splitChunks: {
			minSize: 0,
			name:false,
			cacheGroups: {
				commons: {
					chunks: "all",//加入按需加载后，设为all将所有模块包括在优化范围内
					// name: "commons",
					minChunks: 2,
					maxInitialRequests: 5, // 默认为3，无法满足我们的分包数量
				},
				vendor: {
					test: /node_modules/,
					chunks: "initial",
					name: "vendor",
					// priority: 10,
					// enforce: true
				}
			}
		}
	},
	output: {
		path: path.join(__dirname, "dist"),
		filename: "[name].js",
	}
};

```
