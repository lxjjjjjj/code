# 发展史
## http 0.9 
最早时候只支持传输html，请求中没有任何请求头没有描述数据的信息。只有一个get请求。服务器发送完毕，就关闭TCP连接，同一个TCP连接只能发送一个http请求。

## http 1.0 
引入了请求头和响应头，增加了status code和header等描述信息。增加了post put 请求，多字符集的支持，多部分的发送，权限，缓存。

## http 1.1
持久连接,创建tcp连接后可以不关闭。在http 1.1中默认开启了一个请求头connect:keep-alive进行在一个tcp链接的复用。pipeline一个tcp连接可以发送多个http请求。当然即使引入了长链接keep-alive，还存在一个问题就是基于http 1.0中是一个请求发送得到响应后才开始发送下一个请求，针对这个机制1.1提出了管线化pipelining机制，但是需要注意的是服务器对应同一tcp链接上的请求是一个一个去处理的，服务端都是按照请求顺序处理的第二个请求要等第一个请求处理完才能被处理。所以这就会导致一个比较严重的问题队头阻塞。

如果说第一个发送的请求丢包了，那么服务器会等待这个请求重新发送过来在进行返回处理。之后才会处理下一个请求。即使浏览器是基于pipelining去多个请求同时发送的。


## http 2.0 
提出了很多个优化点，其中最著名的就是解决了http1.1中的队头阻塞问题。一个TCP连接上完成承载任意数量的双向数据流

* 多路复用: 支持使用同一个tcp链接，基于二进制(之前是字符串传输)分帧层进行发送多个请求，支持同时发送多个请求,同时服务器也可以处理不同顺序的请求而不必按照请每个请求的顺序进行处理返回。这就解决了http 1.1中的队头阻塞问题。

* 头部压缩: 在http2协议中对于请求头进行了压缩达到提交传输性能。通讯双方各自缓存一份头部字段表，既避免了重复header的传输，又减小了需要传输的大小。
对于相同的数据，不再通过每次请求和响应发送，通信期间几乎不会改变通用键-值对(用户代理、可接受的媒体类型，等等)只需发送一次。如果首部发生了变化，则只需将变化的部分加入到header帧中，改变的部分会加入到头部字段表中。

* Server push: http2中支持通过服务端主动推送给客户端对应的资源从而让浏览器提前下载缓存对应资源。如果正常客户端请求index.html的话，这个html里面有请求css和js文件，所以，需要重新请求css和js文件，但是http2.0能够“预测”主请求的依赖资源，在响应主请求的同时，主动并发推送依赖资源至客户端。推送将js和css文件一起和index.html一起返回。减少了请求。
### http2.0推送实现
#### 1、标识依赖资源
```
W3C候选推荐标准（https://www.w3.org/TR/preload/）建议了依赖资源的两种做法：文件内<link>标签和HTTP头部携带, 表示该资源后续会被使用, 可以预请求, 关键字preload修饰这个资源, 写法如下：
a) 静态Link标签法:
<link rel="preload" href="push.css" as="style">
b) HTTP头表示法：
Link: <push.css>; rel=preload; as=style
其中rel表明了资源</push.css>是预加载的，as表明了资源的文件类型。另外，link还可以用nopush修饰，表示浏览器可能已经有该资源缓存，指示有推送能力的服务端不主动推送资源，只有当浏览器先检查到没有缓存，才去指示服务端推送资源，nopush格式写成：
Link: </app/script.js>; rel=preload; as=script;nopush。
```
#### 2、推送资源
```
用户访问CDN，主要包括直接访问的边缘节点, 若干中间节点和客户源站，路径中的每层都可以对请求做分析，预测可能的依赖资源，通过插入静态<link>标签或者增加响应头部返回给浏览器。 CDN的推送主要采用头部携带推送信息。
a) 客户端指定推送资源
客户端通过url或者请求头说明需要的资源url，写法如下：
Url：http://http2push.gtimg.com/simple_push.html?req-push=simple_push.js
或者：
GET /simple_push.html HTTP/1.1
Host: http://http2push.gtimg.com
User-Agent: curl/7.49.1
Accept: /
X-Push-Url: simple_push.js
b) CDN节点指定推送资源
CDN节点针对请求资源配置推送资源, 基础配置如下:
location ~ “/simple_push.html$” {
http2_server_push_url /simple_push.js
}
c) 源站指定推送资源
通过增加响应头link通知客户端或者CDN节点，后续希望推送的依赖资源，中间具有 推送功能的节点(如CDN节点)可以基于此信息进行资源请求与推送.
```

[preload和push的区别](https://zhuanlan.zhihu.com/p/48521680)
### http3.0
基于tcp下就难免存在阻塞问题，如果发生丢包就需要等待上一个包。在http3彻底解决了tcp的队头阻塞问题，它是基于udp协议并且在上层增加了一层QUIC协议。


## 关于http 1.1的pipelining机制和http 2.0的多路复用
HTTP/1.1 without pipelining： 必须响应 TCP 连接上的每个 HTTP 请求，然后才能发出下一个请求。


HTTP/1.1 with pipelining: 可以立即发出 TCP 连接上的每个 HTTP 请求，而无需等待前一个请求的响应返回。响应将以相同的顺序返回。


HTTP/2 multiplexing:  TCP 连接上的每个 HTTP 请求都可以立即发出，而无需等待先前的响应返回。响应可以按任何顺序返回。

## https
在HTTP协议中有可能存在信息窃取或身份伪装等安全问题。数据隐私性，内容经过对称加密，每个连接生成一个唯一的加密密钥。并建立一个信息安全通道，来保证传输过程中的数据安全。对网站服务器进行真实身份认证。第三方无法伪造服务端（客户端）身份。数据完整性：内容传输经过完整性校验。

[https](https://juejin.cn/post/6844903830916694030)

HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信了。

### 解决内容可能被窃听的问题——加密
https利用TLS/SSL进行对称加密+非对称加密,对称密钥的好处是解密的效率比较快,非对称密钥的好处是可以使得传输的内容不能被破解，因为就算你拦截到了数据，但是没有对应的私钥，也是不能破解内容的。在交换密钥环节使用非对称加密方式，之后的建立通信交换报文阶段则使用对称加密方式。

### 解决报文可能遭篡改问题——数字签名

网络传输过程中需要经过很多中间节点，虽然数据无法被解密，但可能被篡改，那如何校验数据的完整性呢？----校验数字签名。

数字签名有两种功效：

能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。
数字签名能确定消息的完整性,证明数据是否未被篡改过。

数字签名如何生成

将一段文本先用Hash函数生成消息摘要，然后用发送者的私钥加密生成数字签名，与原文文一起传送给接收者。接下来就是接收者校验数字签名的流程了。

接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用HASH函数对收到的原文产生一个摘要信息，与上一步得到的摘要信息对比。如果相同，则说明收到的

### 解决通信方身份可能被伪装的问题——数字证书

数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。
数字证书验证流程
服务器的运营人员向第三方机构CA提交公钥、组织信息、个人信息(域名)等信息并申请认证;
如果信息审核通过，CA会向申请者签发认证文件-证书。
客户端 Client 向服务器 Server 发出请求时，Server 返回证书文件;
客户端 Client 读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应 CA的公钥解密签名数据，对比证书的信息摘要，如果一致，

### https工作流程

1.Client发起一个HTTPS,Client知道需要连接Server的443（默认）端口。
2.Server把事先配置好的公钥证书返回给客户端。
3.Client验证公钥证书：比如是否在有效期内等信息如果验证通过则继续，不通过则显示警告信息。
4.Client使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给Server。
5.Server使用自己的私钥（private key）解密这个消息，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。
6.Server使用对称密钥加密“明文内容A”，发送给Client。
7.Client使用对称密钥解密响应的密文，得到“明文内容A”。
8.Client再次发起HTTPS的请求，使用对称密钥加密请求的“明文内容B”，然后Server使用对称密钥解密密文，得到“明文内容B”。


# 跨域

GET HEAD POST 方法请求跨域时不需要预请求

* 允许的ContentType 

text/plain
multipart/form-data
application/x-www-form-urlencoded

* 允许的请求头

Accept Accept-Language Content-Language Content-Type multipart/form-data text/plain
...
如果不是以上条件那么会在跨域的时候发送预请求会通过Method=OPTIONS进行预请求 来告诉浏览器 我接下来的请求是被允许的

# Cache-Control请求头

## 1.可缓存性 
1.Cache-Control: public 代表http请求返回的内容所经过的任何路径中，http代理服务器，客户端，服务器都可以缓存
2.Cache-Control: private 只有发起请求的浏览器才能缓存
3.Cache-Control: no-catch 本地，proxy服务器可以缓存 但是使用之前要去服务器验证
4.Cache-Control: no-store是本地和proxy服务器都不能缓存
## 2.到期max-age=<seconds>
Cache-Control: max-age=<seconds>可以代替max-age在服务器才生效
Cache-Control: s-maxage=<seconds>可以代替max-age但是只有在代理服务器才生效，优先级比max-age高
在代理服务器中s-maxage优先级高于max-age
Cache-Control: max-stale=<seconds> 在max-age过期之后，发起请求一方主动写有max-stale的话代表即便缓存过期了，只要在max-stale时间内，也可以使用缓存的内容，而不需要去服务器重新请求内容
## 3.重新验证
Cache-Control: must-revalidate 如果max-age到期了 那么必须去服务端重新验证内容是否真的过期了 不能直接使用本地缓存
Cache-Control: proxy-revalidate 用于缓存服务器 过期时去服务器重新请求数据
## 4.压缩格式转换
Cache-Control: no-transform 是返回内容过大时，不允许代理服务器压缩格式转换

头只是一个限制声明性的作用，没有强制约束.使用nginx做代理时，做catch 可以配置代理服务器如何做缓存操作配置如何生效

# 资源验证
浏览器创建请求后->本地缓存中如果命中就在本地缓存中取值->如果没有命中的话->代理缓存中找->如果代理服务器没有命中->向服务器请求数据

# get & post 区别
1. GET在浏览器回退时是无害的，而POST会再次提交请求。
2. GET产生的URL地址可以被Bookmark，而POST不可以。
3. GET请求会被浏览器主动cache，而POST不会，除非手动设置。
4. GET请求只能进行url编码，而POST支持多种编码方式。
5. GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
6. GET请求在URL中传送的参数是有长度限制的，而POST么有。
7. 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
8. GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
9. GET参数通过URL传递，POST放在Request body中。
10. GET产生一个TCP数据包；POST产生两个TCP数据包。
11. GET在请求的时候会一次性将header和data发出去，然后服务器响应200（返回数据）；而POST会先发header，等到服务器响应100（continue）的时候再发送data，然后服务器返回200（返回数据）。

# 浏览器的缓存机制

## 缓存位置

从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。
浏览器中的缓存位置一共有四种，按优先级从高到低排列分别是：

Service Worker
Memory Cache
Disk Cache
Push Cache

### Service Worker
是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的
由于它脱离了浏览器的窗体，因此无法直接访问DOM。虽然如此，但它仍然能帮助我们完成很多有用的功能，比如离线缓存、消息推送和网络代理等功能。其中的离线缓存就是 Service Worker Cache

### Memory Cache
是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。内存缓存在缓存资源时并不关心返回资源的HTTP缓存头Cache-Control是什么值，同时资源的匹配也并非仅仅是对URL做匹配，还可能会对Content-Type，CORS等其他特征做校验。
Memory Cache指的是内存缓存，从效率上讲它是最快的。但是从存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了。

### Disk Cache
存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据 优势在于存储容量和存储时长。
比较大的JS、CSS文件会直接被丢进磁盘，反之丢进内存
内存使用率比较高的时候，文件优先进入磁盘

### Push Cache
推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂

## 缓存过程分析
浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的

        第一次发起http请求
浏览器----------------------->浏览器缓存      
浏览器<-----------------------没有缓存的结果和缓存标识
                   发起http请求
浏览器--------------------------------------->服务器
       返回缓存结果和缓存标识
服务器------------------------>浏览器

浏览器将结果和缓存标识存入浏览器缓存中，浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识，浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中。

## 强缓存

不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size显示from disk cache或from memory cache。强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control。

1.Expires
缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间，需要和Last-modified结合使用。Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。
Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。Expires: Wed, 22 Oct 2018 08:41:00 GMT表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。

2.Cache-Control
在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存。比如当Cache-Control:max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存

两者同时存在的话，Cache-Control优先级高于Expires；在某些不支持HTTP1.1的环境下，Expires就会发挥用处。

强缓存不关心服务器端文件是否已经更新，这可能会导致加载文件不是服务器端最新的内容，那我们如何获知服务器端内容是否已经发生了更新呢？此时我们需要用到协商缓存策略。

## 协商缓存
协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况： 协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag 。

协商缓存生效，返回304和Not Modified
          发起http请求                      缓存失效返回缓存标识                 携带缓存标识发起http请求
浏览器-----------------------> 浏览器缓存  ----------------------->  浏览器  --------------------------> 服务器 304该资源无更新 获取该请求的缓存结果

协商缓存失效，返回200和请求结果
          发起http请求                      缓存失效返回缓存标识               携带缓存标识发起http请求            200该资源更新了返回请求结果，将请求结果和标识存入缓存
浏览器-----------------------> 浏览器缓存  -----------------------> 浏览器 ---------------------------> 浏览器  --------------------------------------------> 浏览器缓存

### Last-Modified 和 If-Modified-Since
Last-Modified值是这个资源在服务器上的最后修改时间,浏览器下一次请求这个资源，浏览器检测到有 Last-Modified这个header，于是添加If-Modified-Since这个header，值就是Last-Modified中的值；服务器再次收到这个资源请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回304和空的响应体，直接从缓存读取，如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200。
### ETag和If-None-Match
Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag是否一致

首先在精确度上，Etag要优于Last-Modified。 第二在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。 第三在优先级上，服务器校验优先考虑Etag

如果什么缓存策略都没设置，那么浏览器会怎么处理？ 对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间。

### 实际场景应用缓存策略

频繁变动的资源 Cache-Control: no-cache，使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。

不常变化的资源 Cache-Control: max-age=31536000，为了解决更新的问题，就需要在文件名(或者路径)中添加 hash， 版本号等动态字符，之后更改动态字符，从而达到更改引用 URL 的目的，让之前的强制缓存失效

用户在浏览器如何操作时，会触发怎样的缓存策略。主要有 3 种：

打开网页，地址栏输入地址： 查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。
普通刷新 (F5)：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)。其次才是 disk cache。
强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control: no-cache(为了兼容，还带了 Pragma: no-cache),服务器直接返回 200 和最新内容。
