# 发展史
* http 0.9 最早时候只支持传输html，请求中没有任何请求头。

* http 1.0 引入了请求头和响应头，这样的话就可以根据请求头区分传输的内容是图片还是html又或是js。

* http 1.1 针对http1.0每一次请求都会发送请求建立tcp链接，请求结束后断开tcp链接。这无疑是非常耗时的。所以在http 1.1中默认开启了一个请求头connect:keep-alive进行在一个tcp链接的复用。当然即使引入了长链接keep-alive，还存在一个问题就是基于http 1.0中是一个请求发送得到响应后才开始发送下一个请求，针对这个机制1.1提出了管线化pipelining机制，但是需要注意的是服务器对应同一tcp链接上的请求是一个一个去处理的，所以这就会导致一个比较严重的问题队头阻塞。

如果说第一个发送的请求丢包了，那么服务器会等待这个请求重新发送过来在进行返回处理。之后才会处理下一个请求。即使浏览器是基于pipelining去多个请求同时发送的。


* http 2.0 提出了很多个优化点，其中最著名的就是解决了http1.1中的队头阻塞问题。

多路复用: 支持使用同一个tcp链接，基于二进制分帧层进行发送多个请求，支持同时发送多个请求,同时服务器也可以处理不同顺序的请求而不必按照请每个请求的顺序进行处理返回。这就解决了http 1.1中的队头阻塞问题。

头部压缩: 在http2协议中对于请求头进行了压缩达到提交传输性能。

Server push: http2中支持通过服务端主动推送给客户端对应的资源从而让浏览器提前下载缓存对应资源。

* http3.0: 基于tcp下就难免存在阻塞问题，如果发生丢包就需要等待上一个包。在http3彻底解决了tcp的队头阻塞问题，它是基于udp协议并且在上层增加了一层QUIC协议。


## 关于http 1.1的pipelining机制和http 2.0的多路复用
HTTP/1.1 without pipelining： 必须响应 TCP 连接上的每个 HTTP 请求，然后才能发出下一个请求。


HTTP/1.1 with pipelining: 可以立即发出 TCP 连接上的每个 HTTP 请求，而无需等待前一个请求的响应返回。响应将以相同的顺序返回。


HTTP/2 multiplexing:  TCP 连接上的每个 HTTP 请求都可以立即发出，而无需等待先前的响应返回。响应可以按任何顺序返回。




