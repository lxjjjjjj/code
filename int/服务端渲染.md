[原文链接](https://zhuanlan.zhihu.com/p/76967335)
[项目地址](https://github.com/lxjjjjjj/blog-ssr)
# 客户端渲染 vs 服务端渲染

## 客户端渲染
浏览器下载html文本以及js脚本，通过js的不断解析执行构建dom树，动态改变dom树结构和样式。

### 好处
网络传输数据量小、减少了服务器压力、前后端分离、局部刷新，无需每次请求完整页面、交互好可实现各种效果

### 坏处
不利于SEO、爬虫看不到完整的程序源码、首屏渲染慢（渲染前需要下载一堆js和css等），

## 服务端渲染

服务端渲染就是在浏览器请求页面URL的时候，服务端将我们需要的HTML文本组装好，并返回给浏览器，这个HTML文本被浏览器解析之后，不需要经过 JavaScript 脚本的执行，即可直接构建出希望的 DOM 树并展示到页面中。服务端渲染的模式下，当用户第一次请求页面时，由服务器把需要的组件或页面渲染成 HTML 字符串，然后把它返回给客户端。客户端拿到手的，是可以直接渲染然后呈现给用户的 HTML 内容，不需要为了生成 DOM 内容自己再去跑一遍 JS 代码。使用服务端渲染的网站，可以说是“所见即所得”，页面上呈现的内容，我们在 html 源文件里也能找到。

### 好处
首屏渲染快、利于SEO、可以生成缓存片段，生成静态化文件、节能（对比客户端渲染的耗电）

### 过程
服务端渲染：浏览器发送请求 -> Node应用服务器匹配路由 -> 数据预取：Node服务器调用底层服务拿到asyncData存入store -> Node端根据store生成html字符串返回给浏览器 -> 浏览器接收到html字符串将其激活

```
1.服务端运行react代码生成html
2.发送html给浏览器
3.浏览器接到内容显示
4.浏览器加载js文件
5.js代码执行并接管页面工作
```

# 服务端渲染的重点----同构

代码复杂度增加。为了实现服务端渲染，应用代码中需要兼容服务端和客户端两种运行情况，而一部分依赖的外部扩展库却只能在客户端运行，需要对其进行特殊处理，才能在服务器渲染应用程序中运行。

在服务端渲染中，有两种页面渲染的方式：

前端服务器通过请求后端服务器获取数据并组装HTML返回给浏览器，浏览器直接解析HTML后渲染页面
浏览器在交互过程中，请求新的数据并动态更新渲染页面

### 同构的条件

客户端与服务端的路由、模型组件、数据模型的共享。

所谓同构，通俗的讲，就是一套React代码在服务器上运行一遍，到达浏览器又运行一遍。服务端渲染完成页面结构，浏览器端渲染完成事件绑定。

### 同构组件的渲染

如果你调用ReactDOM.hydrate()一个已经有这个服务器渲染标记的节点，React 将保留它并且只附加事件处理程序，让你有一个非常高性能的首次加载体验。

粗体字是主要区别。render如果初始 DOM 和当前 DOM 之间存在差异，可能会更改您的节点。hydrate只会附加事件处理程序。


### 事件绑定问题
react-dom/server下的renderToString并没有做事件相关的处理，因此返回给浏览器的内容不会有事件绑定，那如何进行浏览器端的事件绑定。唯一的方式就是让浏览器去拉取JS文件执行，让JS代码来控制。于是服务端返回的代码变成了这样: 多了一个script标签。它拉取的JS代码就是来完成同构的。

```
<html>
      <head>
        <title>ssr</title>
      </head>
      <body>
        <div id="root">
            <div>this is xxxx</div>
            <button>click</button>
        </div>
        <script src='/index.js'></script>
      </body>
    </html>
```
如何实现的
```
//client/index. js
import React from 'react';
import ReactDom from 'react-dom';
import Home from '../containers/Home';

ReactDom.hydrate(<Home />, document.getElementById('root'))
```
然后用webpack将其编译打包成index.js:
```
//webpack.client.js
const path = require('path');
const merge = require('webpack-merge');
const config = require('./webpack.base');

const clientConfig = {
  mode: 'development',
  entry: './src/client/index.js',
  output: {
    filename: 'index.js',
    path: path.resolve(__dirname, 'public')
  },
}

module.exports = merge(config, clientConfig);

//webpack.base.js
module.exports = {
  module: {
    rules: [{
      test: /\.js$/,
      loader: 'babel-loader',
      exclude: /node_modules/,
      options: {
        presets: ['@babel/preset-react',  ['@babel/preset-env', {
          targets: {
            browsers: ['last 2 versions']
          }
        }]]
      }
    }]
  }
}

//package.json的script部分
  "scripts": {
    "dev": "npm-run-all --parallel dev:**",
    "dev:start": "nodemon --watch build --exec node \"./build/bundle.js\"",
    "dev:build:server": "webpack --config webpack.server.js --watch",
    "dev:build:client": "webpack --config webpack.client.js --watch"
  },
```
在这里需要开启express的静态文件服务：

```
const app = express();
app.use(express.static('public'));
```
现在前端的script就能拿到控制浏览器的JS代码啦。
### 同构中的路由问题

现在写一个路由的配置文件
```
// Routes.js
import React from 'react';
import {Route} from 'react-router-dom'
import Home from './containers/Home';
import Login from './containers/Login'

export default (
  <div>
    <Route path='/' exact component={Home}></Route>
    <Route path='/login' exact component={Login}></Route>
  </div>
)
```
在客户端的控制代码，也就是上面写过的client/index.js中，要做相应的更改
```
import React from 'react';
import ReactDom from 'react-dom';
import { BrowserRouter } from 'react-router-dom'
import Routes from '../Routes'

const App = () => {
  return (
    <BrowserRouter>
      {Routes}
    </BrowserRouter>
  )
}
ReactDom.hydrate(<App />, document.getElementById('root'))
```
此时控制台会报错： Expected server HTML to contain a matching <div> in <div>
因为在Routes.js中，每个Route组件外面包裹着一层div，但服务端返回的代码中并没有这个div,所以报错。如何去解决这个问题？需要将服务端的路由逻辑执行一遍

```
// server/index.js
import express from 'express';
import {render} from './utils';

const app = express();
app.use(express.static('public'));
//注意这里要换成*来匹配
app.get('*', function (req, res) {
   res.send(render(req));
});

app.listen(3001, () => {
  console.log('listen:3001')
});
// server/utils.js
import Routes from '../Routes'
import { renderToString } from 'react-dom/server';
//重要是要用到StaticRouter
import { StaticRouter } from 'react-router-dom'; 
import React from 'react'

export const render = (req) => {
  //构建服务端的路由
  const content = renderToString(
    <StaticRouter location={req.path} >
      {Routes}
    </StaticRouter>
  );
  return `
    <html>
      <head>
        <title>ssr</title>
      </head>
      <body>
        <div id="root">${content}</div>
        <script src="/index.js"></script>
      </body>
    </html>
  `
}
```

### 同构项目中引入redux
对于store的连接操作，在同构项目中分两个部分，一个是与客户端store的连接，另一部分是与服务端store的连接。都是通过react-redux中的Provider来传递store的。

#### 客户端
```
//src/client/index.js
import React from 'react';
import ReactDom from 'react-dom';
import {BrowserRouter, Route} from 'react-router-dom';
import { Provider } from 'react-redux';
import store from '../store'
import routes from '../routes.js'

const App = () => {
  return (
    <Provider store={store}>
      <BrowserRouter>
        {routes}
      </BrowserRouter>
    </Provider>
  )
}

ReactDom.hydrate(<App />, document.getElementById('root'))
```
#### 服务端
```
//src/server/index.js的内容保持不变
//下面是src/server/utils.js
import Routes from '../Routes'
import { renderToString } from 'react-dom/server';
import { StaticRouter } from 'react-router-dom'; 
import { Provider } from 'react-redux';
import React from 'react'

export const render = (req) => {
  const content = renderToString(
    <Provider store={store}>
      <StaticRouter location={req.path} >
        {Routes}
      </StaticRouter>
    </Provider>
  );
  return `
    <html>
      <head>
        <title>ssr</title>
      </head>
      <body>
        <div id="root">${content}</div>
        <script src="/index.js"></script>
      </body>
    </html>
  `
}
```
##### 注意的坑

上面的store是一个单例，当这个单例导出去后，所有的用户用的是同一份store，这是不应该的。那么这么解这个问题呢？

在全局的store/index.js下修改如下：
```
//导出部分修改
export default  () => {
  return createStore(reducer, applyMiddleware(thunk))
}
```
这样在客户端和服务端的js文件引入时其实引入了一个函数，把这个函数执行就会拿到一个新的store,这样就能保证每个用户访问时都是用的一份新的store。


### 异步数据的服务端渲染方案(数据注水与脱水)

在平常客户端的React开发中，我们一般在组件的componentDidMount生命周期函数进行异步数据的获取。但是，在服务端渲染中却出现了问题。

```
import { getHomeList } from './store/actions'
  //......
  componentDidMount() {
    this.props.getList();
  }
  //......
  const mapDispatchToProps = dispatch => ({
    getList() {
      dispatch(getHomeList());
    }
})
//actions.js
import { CHANGE_LIST } from "./constants";
import axios from 'axios'

const changeList = list => ({
  type: CHANGE_LIST,
  list
})

export const getHomeList = () => {
  return dispatch => {
    //另外起的本地的后端服务
    return axiosInstance.get('localhost:4000/api/news.json')
      .then((res) => {
        const list = res.data.data;
        dispatch(changeList(list))
      })
  }
}
//reducer.js
import { CHANGE_LIST } from "./constants";

const defaultState = {
  name: 'sanyuan',
  list: []
}

export default (state = defaultState, action) => {
  switch(action.type) {
    case CHANGE_LIST:
      const newState = {
        ...state,
        list: action.list
      }
      return newState
    default:
      return state;
  }
}
```
现在页面能够正常渲染，但是打开网页源代码。源代码里面并没有这些列表数据啊！那这是为什么呢？

让我们来分析一下客户端和服务端的运行流程，当浏览器发送请求时，服务器接受到请求，这时候服务器和客户端的store都是空的，紧接着客户端执行componentDidMount生命周期中的函数，获取到数据并渲染到页面，然而服务器端始终不会执行componentDidMount，因此不会拿到数据，这也导致服务器端的store始终是空的。换而言之，关于异步数据的操作始终只是客户端渲染。

现在的工作就是让服务端将获得数据的操作执行一遍，以达到真正的服务端渲染的效果。

#### 解决办法就是改造路由
```
import Home from './containers/Home';
import Login from './containers/Login';

export default [
{
  path: "/",
  component: Home,
  exact: true,
  loadData: Home.loadData,//服务端获取异步数据的函数
  key: 'home'
},
{
  path: '/login',
  component: Login,
  exact: true,
  key: 'login'
}
}];
```
此时客户端和服务端中编写的JSX代码也发生了相应变化

```
//客户端
//以下的routes变量均指routes.js导出的数组
<Provider store={store}>
  <BrowserRouter>
      <div>
        {
            routers.map(route => {
                <Route {...route} />
            })
        }
      </div>
  </BrowserRouter>
</Provider>
//服务端
<Provider store={store}>
  <StaticRouter>
      <div>
        {
            routers.map(route => {
                <Route {...route} />
            })
        }
      </div>
  </StaticRouter>
</Provider>
```
其中配置了一个loadData参数，这个参数代表了服务端获取数据的函数。每次渲染一个组件获取异步数据时，都会调用相应组件的这个函数。因此，在编写这个函数具体的代码之前，我们有必要想清楚如何来针对不同的路由来匹配不同的loadData函数。


在server/utils.js中加入以下逻辑
```
import { matchRoutes } from 'react-router-config';
  //调用matchRoutes用来匹配当前路由(支持多级路由)
  const matchedRoutes = matchRoutes(routes, req.path)
  //promise对象数组
  const promises = [];
  matchedRoutes.forEach(item => {
    //如果这个路由对应的组件有loadData方法
    if (item.route.loadData) {
      //那么就执行一次,并将store传进去
      //注意loadData函数调用后需要返回Promise对象
      promises.push(item.route.loadData(store))
    }
  })
  Promise.all(promises).then(() => {
      //此时该有的数据都已经到store里面去了
      //执行渲染的过程(res.send操作)
  }
  )
```
现在就可以安心的写我们的loadData函数，其实前面的铺垫工作做好后，这个函数是相当容易的。
```
import { getHomeList } from './store/actions'

Home.loadData = (store) => {
    return store.dispatch(getHomeList())
}
//actions.js
export const getHomeList = () => {
  return dispatch => {
    return axios.get('xxxx')
      .then((res) => {
        const list = res.data.data;
        dispatch(changeList(list))
      })
  }
}
```
根据这个思路，服务端渲染中异步数据的获取功能就完成啦。

#### 数据的注水和脱水
其实目前做了这里还是存在一些细节问题的。比如当我将生命周期钩子里面的异步请求函数注释，现在页面中不会有任何的数据，但是打开网页源代码，却发现:

数据已经挂载到了服务端返回的HTML代码中。那这就说明服务端和客户端的store不同步的问题。

其实也很好理解。当服务端拿到store并获取数据后，客户端的js代码又执行一遍，在客户端代码执行的时候又创建了一个空的store，两个store的数据不能同步。

那如何才能让这两个store的数据同步变化呢?

首先，在服务端获取获取之后，在返回的html代码中加入这样一个script标签：

```
<script>
  window.context = {
    state: ${JSON.stringify(store.getState())}
  }
</script>
```

这叫做数据的“注水”操作，即把服务端的store数据注入到window全局环境中。 接下来是“脱水”处理，换句话说也就是把window上绑定的数据给到客户端的store，可以在客户端store产生的源头进行，即在全局的store/index.js中进行。

```
//store/index.js
import {createStore, applyMiddleware, combineReducers} from 'redux';
import thunk from 'redux-thunk';
import { reducer as homeReducer } from '../containers/Home/store';

const reducer = combineReducers({
  home: homeReducer
})
//服务端的store创建函数
export const getStore = () => {
  return createStore(reducer, applyMiddleware(thunk));
}
//客户端的store创建函数
export const getClientStore = () => {
  const defaultState = window.context ? window.context.state : {};
  return createStore(reducer, defaultState, applyMiddleware(thunk));
}
```
至此，数据的脱水和注水操作完成。但是还是有一些瑕疵，其实当服务端获取数据之后，客户端并不需要再发送Ajax请求了，而客户端的React代码仍然存在这样的浪费性能的代码。怎么办呢？
```
componentDidMount() {
  //判断当前的数据是否已经从服务端获取
  //要知道，如果是首次渲染的时候就渲染了这个组件，则不会重复发请求
  //若首次渲染页面的时候未将这个组件渲染出来，则一定要执行异步请求的代码
  //这两种情况对于同一组件是都是有可能发生的
  if (!this.props.list.length) {
    this.props.getHomeList()
  }
}
```



### 服务端css的引入
需要依靠一个库实现
## 万不得已不用ssr得理由
其实不到万不得已我们是用不着它的，SSR所解决的最大的痛点在于SEO，但它同时带来了更昂贵的成本。不仅因为服务端渲染需要更加复杂的处理逻辑，还因为同构的过程需要服务端和客户端都执行一遍代码，这虽然对于客户端并没有什么大碍，但对于服务端却是巨大的压力，因为数量庞大的访问量，对于每一次访问都要另外在服务器端执行一遍代码进行计算和编译，大大地消耗了服务器端的性能，成本随之增加。如果访问量足够大的时候，以前不用SSR的时候一台服务器能够承受的压力现在或许要增加到10台才能抗住。痛点在于SEO，但如果实际上对SEO要求并不高的时候，那使用SSR就大可不必了。

万一服务端渲染出错了怎么办？万一服务器压力飙升了怎么办（因为服务端渲染是CPU密集型操作，很耗CPU资源

具体可以采用的降级方案有：
* 单个流量降级 -- 偶发的服务端渲染失败降级为客户端渲染
* Disconf / Apollo配置降级 -- 分布式配置平台修改配置主动降级，比如可预见性的大流量情况下（双十一），可提前通过配置平台将整个应用集群都降级为客户端渲染
* CPU阈值降级 -- 物理机 / Docker实例CPU资源占用达到阈值触发降级，避免负载均衡服务器在某些情况下给某台应用服务器导入过多流量，使得单台应用服务器的CPU负载过高
* 旁路系统降级 -- 旁路系统跑定时任务监控应用集群状态，集群资源占用达到设定阈值将整个集群降级（或触发集群的自动扩容）
* 渲染服务集群降级 -- 若渲染服务和接口服务是独立的服务，当渲染服务集群宕机，html的获取逻辑回溯到Nginx获取，此时触发客户端渲染，通过ajax调用接口服务获取数据
  

## node作中间层及请求代码优化
为什么要引入node作为中间层呢？它是处在哪两者的中间？又是解决了什么场景下的问题？

在不用中间层的前后端分离开发模式下，前端一般直接请求后端的接口。但真实场景下，后端所给的数据格式并不是前端想要的，但处于性能原因或者其他的因素接口格式不能更改，这时候需要在前端做一些额外的数据处理操作。前端来操作数据本身无可厚非，但是当数据量变得庞大起来，那么在客户端就是产生巨大的性能损耗，甚至影响到用户体验。在这个时候，node中间层的概念便应运而生。

一般的中间层工作流是这样的:前端每次发送请求都是去请求node层的接口，然后node对于相应的前端请求做转发，用node去请求真正的后端接口获取数据，获取后再由node层做对应的数据计算等处理操作，然后返回给前端。这就相当于让node层替前端接管了对数据的操作。



