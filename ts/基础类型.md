# 什么是ts
Typescript 是一个强类型的 JavaScript 超集，ts有js没有的语法语义规则，但又是向下兼容js。支持ES6语法，支持面向对象编程的概念，如类、接口、继承、泛型等。Typescript并不直接在浏览器上运行，需要编译器编译成纯Javascript来运行。
# 为什么需要TypeScript
简单来说就是因为JavaScript是弱类型, 很多错误只有在运行时才会被发现,而TypeScript提供了一套静态检测机制, 可以帮助我们在编译时就发现错误。使得代码质量更好，更健壮。
1.类型一定程度上可以充当文档
2.IDE自动填充、自动联想

# TypeScript 基础类型

## 字面量
```
// a声明为10 不能更改
let a:10
// 此代码报错 不能赋值为11
a = 11
```
```
// 字面量类型声明基础用法
// b声明为man或者woman 可以使用|来连接多个类型
let b : "man" | "woman"
b = "man"
b = "woman"
// 此代码报错 不是定义的字面量类型
b = "vike"
```
## Boolean Number String Symbol Array
```
let isDone: boolean = false;
let count: number = 10;
let name: string = "semliker";
const sym = Symbol();
let obj = {
  [sym]: "semlinker",
};

console.log(obj[sym]); // semlinker 
let list: number[] = [1, 2, 3];
let list: Array<number> = [1, 2, 3]; // Array<number>泛型语法

```
## Enum类型

使用枚举我们可以定义一些带名字的常量。 使用枚举可以清晰地表达意图或创建一组有区别的用例。 TypeScript 支持数字的和基于字符串的枚举。

### 数字枚举
```
enum Direction {
  NORTH,
  SOUTH,
  EAST,
  WEST,
}

let dir: Direction = Direction.NORTH;
let i = { name: string, dir: Direction.NORTH}
```
默认情况下，NORTH 的初始值为 0，其余的成员会从 1 开始自动增长。换句话说，Direction.SOUTH 的值为 1，Direction.EAST 的值为 2，Direction.WEST 的值为 3。
```
ES5代码如下：
"use strict";
var Direction;
(function (Direction) {
  Direction[(Direction["NORTH"] = 0)] = "NORTH";
  Direction[(Direction["SOUTH"] = 1)] = "SOUTH";
  Direction[(Direction["EAST"] = 2)] = "EAST";
  Direction[(Direction["WEST"] = 3)] = "WEST";
})(Direction || (Direction = {}));
var dir = Direction.NORTH;
```
当然我们也可以设置 NORTH 的初始值，比如：
```
enum Direction {
  NORTH = 3,
  SOUTH,
  EAST,
  WEST,
}
```
那么下面的值也会依次递增，SOUTH=4，EAST=5，WEST=6

**注意：枚举对象递增，枚举对象成员递增值为1。枚举对象成员递增只会看当前值的前一个枚举成员是否有值，有值的话后面依次跟着递增。跟第一个枚举成员值无关**
```
enum device {
    phone = 2,
    notebook = 1,
    desktop
}

console.log(device.phone) // 2
console.log(device[2]) // desktop
```
#### 数字枚举的反向映射

```
enum device {
      phone
      notebook,
      desktop
}
```
**通过上面栗子我们可以知道，device.notebook = 1。但还可以通过device[1]获取出来notebook，这就是因为存在反向映射（key和value可以互相访问）需要注意的是，只有数字枚举成员才会有反向映射，字符串或其它值是没有的**

### 字符串枚举
字符串枚举对象是没有反向映射的。
```
enum device {
    phone = "1",
    notebook = "2",
    desktop = "3"
}

编译后的代码

var device
(function(device){
    device['phone']}='1';
    device['notebook']}='2';
    device['desktop']}='3';
})(device || (device={}))
```
字符串枚举是没有递增的，当前的枚举成员前一个值为字符串，那么当前的枚举对象如果不赋值就会报错。

### 常量枚举
它是使用 const 关键字修饰的枚举，常量枚举会使用内联语法，不会为枚举类型编译生成任何 JavaScript。它与普通枚举不同的是，它会在编译阶段删除该对象，且不能访问该枚举对象，只能访问该枚举对象成员。常量枚举的成员只能是常量枚举表达式，不可以使用计算值
```
const enum Direction {
  NORTH,
  SOUTH,
  EAST,
  WEST,
}

let dir: Direction = Direction.NORTH;
以上代码对应的 ES5 代码如下：
"use strict";
var dir = 0 /* NORTH */;
```
```
const enum obj {
    A = 1,
    B = 3 * 6,
    C = 1 & 2
}
console.log(obj) // 报错
const enum obj {
    A = 1,
    B = 3 * 6,
    C = 1 & 2
}
console.log(obj.A) // 1
console.log(obj.B) // 8
console.log(obj.C) // 0
```
### 异构枚举
一个枚举对象中可以包括数字枚举成员和字符串枚举成员，就是可以混合使用
```
enum Enum {
  A,
  B,
  C = "C",
  D = "D",
  E = 8,
  F,
}
```
以上代码对于的 ES5 代码如下：
```
"use strict";
var Enum;
(function (Enum) {
    Enum[Enum["A"] = 0] = "A";
    Enum[Enum["B"] = 1] = "B";
    Enum["C"] = "C";
    Enum["D"] = "D";
    Enum[Enum["E"] = 8] = "E";
    Enum[Enum["F"] = 9] = "F";
})(Enum || (Enum = {}));
```
通过观察上述生成的 ES5 代码，我们可以发现数字枚举相对字符串枚举多了 “反向映射”：
```
console.log(Enum.A) //输出：0
console.log(Enum[0]) // 输出：A
```
下面这种是会报错的，“含字符串值成员的枚举中不允许使用计算值”，枚举对象成员有字符串的则不能再设置其它枚举对象成员为计算的值(3 * 6)。但是可以直接写字面量的。下面我们会讲到计算
```
enum Person {
    name = "前端娱乐圈",
    age = 18
}
enum Person {
    name = "前端娱乐圈",
    age = 3 * 6
}
```
### 枚举中的计算成员和常量成员
枚举对象成员表达式，只要是表达式那一定就是常量否则就是计算的。所以只需要知道枚举成员是表达式就知道它就是常量。

**判断表达式的条件**

- 一个枚举表达式字面量（主要是字符串字面量或数字字面量）
- 一个对之前定义的常量枚举成员的引用（可以是在不同的枚举类型中定义的）
- 带括号的常量枚举表达式
- 一元运算符 +, -, ~其中之一应用在了常量枚举表达式
- 常量枚举表达式做为二元运算符 +, -, *, /, %, <<, >>, >>>, &, |, ^的操作对象。若常数枚举表达式求值后为 NaN或 Infinity，则会在编译阶段报错。上面这些条件成立之后那么当前枚举成员就是一个常量。常量就是可以在编译阶段求值的
```
enum obj {
    index, // 满足条件 常量
    index1 = index, // 满足条件 常量
    age = 2 << 1, // 满足条件 常量 
    num = 30 | 2, // 满足条件 常量
    num1 = 10 + 29 // 满足条件 常量
}

enum obj {
    nameLen = "前端娱乐圈".length, // 计算的
    num = Math.random() * 100 // 计算的
}
```
### 外部枚举
外部枚举使用declare关键字定义，文档描述：外部枚举用来描述已经存在的枚举类型的形状，意思就是说外部枚举用来描述当前环境中存在的枚举对象。外部枚举和普通枚举的一个区别就是，在外部枚举里面没有初始化的枚举成员会当成一个计算值，而在普通枚举里面则是一个常量。
```
declare enum Enum {
    A = 1,
    B,
    C = 2
}

console.log(Enum);
console.log(Enum.A)
```
上面这种执行完，你会发现不管执行枚举本身还是枚举成员都是报错，"Enum is not defined"。因为外部枚举编译后压根就没有生成。

## Any类型
在 TypeScript 中，任何类型都可以被归为 any 类型。这让 any 类型成为了类型系统的顶级类型（也被称作全局超级类型）。any 类型允许被赋值为任意类型，在any上访问任何属性都是允许的,也允许调用任何方法。

## unknown类型
就像所有类型都可以赋值给 any，所有类型也都可以赋值给 unknown。这使得 unknown 成为 TypeScript 类型系统的另一种顶级类型（另一种是 any），**unknown 类型只能被赋值给 any 类型和 unknown 类型本身。**

现在让我们看看当我们尝试对类型为 unknown 的值执行操作时会发生什么。以下是我们在之前 any 操作不会有报错

```
let value: unknown;

value.foo.bar; // Error
value.trim(); // Error
value(); // Error
new value(); // Error
value[0][1]; // Error
```
### unknown 和 any 的区别

any 可以赋值给其他变量、unknown 类型的变量不能赋给其他变量

### unknown 类型赋值
#### 1、if 判断类型是否相同
```
let s : string
let c : unknown
c = '123'
// if 判断
if (c === 'string') {
    s = c
}
```
#### 2.类型断言 告诉解析器变量的实际类型
```
// 断言 方法1
s = c as string
// 断言 方法2
s = <string> c
```
#### typeof
```
function getDogName() {
 let x: unknown;
 return x;
};
const dogName = getDogName();
// 直接使用
const upName = dogName.toLowerCase(); // Error
// typeof
if (typeof dogName === 'string') {
  const upName = dogName.toLowerCase(); // OK
}
// 类型断言 
const upName = (dogName as string).toLowerCase(); // OK
```
## Tuple 类型