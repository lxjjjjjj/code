[原文链接](https://juejin.cn/post/6881502813105422349)
# 原生组件限制的局部解决方案

在小程序引入「同层渲染」之前，「原生组件」的层级总是最高，不受 z-index 属性的控制，无法与 view、image 等内置组件相互覆盖，cover-view 和 cover-image 组件的出现一定程度上缓解了覆盖的问题，但这样做，就像是写css的时候，写了一堆!important，并不是一个优雅的解决方案。
cover-view 和 cover-image 组件还具有如下限制：

1.无法覆盖textarea、input「原生组件」。
2.只支持基本的定位、布局、文本样式。不支持设置单边的border、background-image、shadow、overflow: visible等。
3.cover-view 支持 overflow: scroll，但不支持动态更新 overflow。
4.cover-view和cover-image的aria-role仅可设置为 button，读屏模式下才可以点击，并朗读出“按钮”；为空时可以聚焦，但不可点击。
5.cover-view和cover-image的子节点如果溢出父节点，容易出现布局错误。
6.支持css transition动画，transition-property 只支持transform (translateX, translateY)与opacity。
7.自定义组件嵌套 cover-view 时，自定义组件的 slot 及其父节点暂不支持通过 wx:if 控制显隐，否则会导致 cover-view 不显示。

随着小程序生态的发展，开发者对「原生组件」的使用场景不断扩大，「原生组件」的这些问题也日趋显现，为了彻底解决「原生组件」带来的种种限制，微信官方对小程序「原生组件」进行了一次重构，引入了 「同层渲染」。

为了解决「原生组件」的层级问题，同时尽可能保留NA组件（指代「原生组件」）的优势，小程序客户端、前端及浏览内核团队一起制定了一套解决方案：由于此方案的控件并非绘制在 NA 贴片层，而是绘制在 WebView 所渲染的页面中，与其他 HTML 控件在同一层级，因此称为 「同层渲染」。在支持「同层渲染」后，「原生组件」与其它 「H5 组件」（指代 HTML5 语言编写的 web 组件）可以随意叠加，层级的限制将不复存在。
你一定也想知道 「同层渲染」 背后究竟采用了什么技术。只有真正理解了 「同层渲染」 背后的机制，才能更高效地使用好这项能力。实际上，小程序的「同层渲染」在 iOS 和 Android 平台下的实现不同，因此下面分成两部分来分别介绍两个平台的实现方案。

# iOS 端「同层渲染」原理
WKWebView: 是 iOS 8 之后提供的一款浏览器组件，iOS 端使用 WKWebView 进行渲染，WKWebView 在内部采用的是分层的方式进行渲染。WKWebView 会将 WebKit 内核生成的 Compositing Layer（合成层）渲染成 iOS 上的一个 WKCompositingView(「原生组件」的一种)。


Compositing Layer: NA 合成层，内核一般会将多个webview内的 DOM 节点渲染到一个 Compositing Layer 上，因此合成层与 DOM 节点之间不存在一对一的映射关系。


WKChildScrollView: 「原生组件」的一种。当把一个 DOM 节点的 CSS 属性设置为 overflow: scroll （低版本需同时设置 -webkit-overflow-scrolling: touch）之后，WKWebView 会为其生成一个 WKChildScrollView，与 DOM 节点存在映射关系，这是一个原生的 UIScrollView 的子类，也就是说 WebView 里的滚动实际上是由真正的原生滚动组件来承载的。WKWebView 这么做是为了可以让 iOS 上的 WebView 滚动有更流畅的体验。虽说 WKChildScrollView 也是「原生组件」，但 WebKit 内核已经处理了它与其他 DOM 节点之间的层级关系，因此你可以直接使用 WXSS 控制层级而不必担心遮挡的问题。

## 渲染原理解析
小程序 iOS 端的「同层渲染」也正是基于 WKChildScrollView 实现的，「原生组件」在 attached 之后会直接挂载到预先创建好的 WKChildScrollView 容器下，大致的流程如下：

小程序前端，在 webview 内创建一个 DOM 节点并设置其 CSS 属性为 overflow: hidden 且 -webkit-overflow-scrolling: touch，生成一个containerId，并将这个WKChildScrollView的位置信息通知给客户端。
前端通知客户端递归搜索查找到该 DOM 节点对应的原生 WKChildScrollView 组件；
将「原生组件」挂载到该 WKChildScrollView 节点上作为其子 View；
WebKit 内核已经处理了WKChildScrollView与对应 DOM 节点之间的层级关系。通过上述流程，小程序的「原生组件」就被插入到 WKChildScrollView 了，也即是在 步骤 1 创建的那个 DOM 节点映射的原生 WKChildScrollView节点。此时，修改这个 DOM 节点的样式属性同样也会应用到「原生组件」上。因此，「同层渲染」的「原生组件」与普通的 H5 组件表现并无二致。

# Android 端「同层渲染」原理
chromium：小程序在 Android 端采用 chromium 作为 WebView 渲染层，与 iOS 不同的是，Android 端的 WebView 是单独进行渲染而不会在客户端生成类似 iOS 那样的 Compositing View (合成层)，经渲染后的 WebView 是一个完整的视图。

WebPlugin：chromium 支持 WebPlugin 机制，WebPlugin 是浏览器内核的一个插件机制，主要用来解析和描述<embed /> 标签。比如 Chrome 浏览器上的 pdf 预览，它就是基于 <embed /> 标签实现的。

内核的渲染流程可分为下面四个步骤。如下如所示：

解析。当内核收到HTML数据时，会构建一颗DOM Tree，并为每个节点计算样式。
排版。遍历DOM Tree，根据样式构建一颗Layout Tree。DOM Tree和Layout Tree上的节点并非一一对应，如果某个 DOM 节点不可见，则不会在Layout Tree上。
绘制。为了提升绘制效率，对Layout Tree中的节点按照一定的规则分为不同的图层（Layer），这些图层也构成一个树状结构，称之为Layer Tree。绘制过程就是遍历Layout Tree，将每个节点的内容绘制到其所在的 Layer 上。在 GPU 硬绘模式下，Layer 存储后端是 GPU 中的纹理-Texture。
合成。内核的合成模块（CC 层）负责将 Layer 按照一定的顺序合成到一起，交给系统的FrameBuffer，最终输出到屏幕上。

从内核渲染流程可以看出，要实现「原生组件」「同层渲染」，就要将「原生组件」作为一个Layer插入到Layer Tree中。 如果能够将「原生组件」渲染到内核提供的Texture上，就可达到「同层渲染」的目的。Android 端的「同层渲染」就是基于 <embed /> 标签结合 chromium 内核扩展来实现的, 大致流程如下:
<embed id="web-plugin" type="plugin/video" width="750" height="600" />
复制代码

WebView 侧创建一个 embed DOM 节点并指定组件类型；
chromium 内核会创建一个 WebPlugin 实例，并生成一个 RenderLayer；
Android 客户端初始化一个对应的「原生组件」；
Android 客户端将「原生组件」的画面绘制到步骤 2 创建的 RenderLayer 所绑定的 SurfaceTexture 上；
绘制完成后内核收到SurfaceTexture内容更新的通知，通知 chromium 内核渲染该 RenderLayer；
chromium 渲染该 embed 节点并上屏。
当「同层渲染」的节点收到事件时，会将事件转发给 Native 组件模块处理。如果 Native 组件不消费事件，内核会再将事件向上冒泡。

这样就实现了把一个「原生组件」渲染到 WebView 上，这个流程相当于给 WebView 添加了一个外置的插件。
这种方式可以用于 map、video、canvas、camera 等「原生组件」的渲染，对于 input 和 textarea，采用的方案是直接对 chromium 的组件进行扩展，来支持一些 WebView 本身不具备的能力。
对比 iOS 端的实现，Android 端的 「同层渲染」 真正将「原生组件」视图加到了 WebView 的渲染流程中且 embed 节点是真正的 DOM 节点，理论上可以将任意 WXSS 属性作用在该节点上。Android 端相对来说是更加彻底的「同层渲染」，但相应的重构成本也会更高一些。

# 「同层渲染」的小缺陷
原生组件」的 「同层渲染」 能力可能会在特定情况下失效，一方面你需要在开发时稍加注意，另一方面「同层渲染」失败会触发 bindrendererror 事件，可在必要时根据该回调做好 UI 的 fallback。

对 Android 端来说，如果用户的设备没有微信自研的 chromium 内核，则会无法切换至 「同层渲染」，此时会在组件初始化阶段触发 bindrendererror。
iOS 端的情况会稍复杂一些：如果在基础库创建同层节点时，节点发生了 WXSS 变化从而引起 WebKit 内核重排，此时可能会出现同层失败的现象。这是因为设置了-webkit-overflow-scrolling属性的 div 块（container），在其下层同时会产生一个 div 块（内层 div）作为渲染使用，在 iOS 设备表现是生成的UIScrollView会有一个子 view 是WKCompositingView，如果改变内层 div 的高度，可能会触发重新渲染，进而导致「原生组件」组件可能被无感知的被移除掉。解决方法：应尽量避免在「原生组件」上频繁修改节点的 WXSS 属性，尤其要尽量避免修改节点的 position 属性。如需对「原生组件」进行变换，强烈推荐使用 transform 而非修改节点的 position 属性。

